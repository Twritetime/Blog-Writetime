import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as e,d as n,o as t}from"./app-BGV7llRK.js";const l={};function h(r,i){return t(),a("div",null,[e(" more "),i[0]||(i[0]=n(`<hr><h2 id="typora-root-url-images" tabindex="-1"><a class="header-anchor" href="#typora-root-url-images"><span>typora-root-url: ./..\\images</span></a></h2><h2 id="一、基础" tabindex="-1"><a class="header-anchor" href="#一、基础"><span>一、基础</span></a></h2><h3 id="_1-面向对象和面向过程的区别" tabindex="-1"><a class="header-anchor" href="#_1-面向对象和面向过程的区别"><span>1. 面向对象和面向过程的区别</span></a></h3><p>面向对象：拆分对象</p><p>面向过程：拆分方法 洗衣机</p><p>面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式，两者的主要区别在于解决问题的方式不同：</p><ul><li><strong>面向过程编程（POP）</strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li><strong>面向对象编程（OOP）</strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p><strong>洗衣机洗衣服：</strong></p><p>面向过程会将任务拆解成一系列的方法，1、打开洗衣机-----&gt;2、放衣服-----&gt;3、放洗衣粉-----&gt;4、清洗-----&gt;5、烘干 面向对象会拆出人和洗衣机两个对象：人：打开洗衣机 放衣服 放洗衣粉 洗衣机：清洗 烘干</p><p>OOP 优点：</p><ul><li><strong>易维护</strong>：由于良好的结构和封装性，OOP 程序通常更容易维护。</li><li><strong>易复用</strong>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。</li><li><strong>易扩展</strong>：模块化设计使得系统扩展变得更加容易和灵活。</li></ul><p>POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。</p><h3 id="_2-面向对象三大特性" tabindex="-1"><a class="header-anchor" href="#_2-面向对象三大特性"><span>2. 面向对象三大特性</span></a></h3><p>封装：属性对内 方法对外 空调</p><p>继承：父类 属性 方法</p><p>多态：对象 属类相同 方法不同 父引用-&gt;子对象</p><p>封装：是指把一个对象的状态信息（属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><p>就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了</p><p>继承：继承父类的方法，并做出自己的改变和/或扩展子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的</p><p>多态：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。</p><p>继承，方法重写，父类引用指向子类对象，无法调用子类特有的功能</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">父类类型 变量名 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 子类对象 </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">变量名</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">方法名()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-string-stringbuffer-stringbuilder-区别" tabindex="-1"><a class="header-anchor" href="#_3-string-stringbuffer-stringbuilder-区别"><span>3. String/StringBuffer/StringBuilder 区别</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324526.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>String 是不可变的字符串，每次修改都会创建新的对象，适用于不经常修改的字符串操作；</p><p>StringBuffer 是可变的字符串，线程安全，适用于多线程环境； StringBuilder 也是可变的字符串，但不是线程安全的，适用于单线程频繁修改字符串的场景。</p><h3 id="_4-和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#_4-和-equals-的区别"><span>4. == 和 equals 的区别</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324528.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>&quot;==&quot;用于比较基本类型的值或引用对象的地址值是否相等</p><p>equals 方法用于比较对象的内容是否相等</p><p>简而言之，&quot;==&quot;比较的是值，equals 比较的是内容</p><h3 id="_5-接口和抽象类的区别" tabindex="-1"><a class="header-anchor" href="#_5-接口和抽象类的区别"><span>5. 接口和抽象类的区别</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324529.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>接口主要是用于制定规范</p><p>抽象类主要为了复用，比较典型的就是模板方法模式</p><p>⼀个类可以实现多个接口，但只能继承⼀个抽象类</p><p>接口中的成员变量只能由 public static final 修饰，而抽象类中的成员变量可以是各种类型的</p><p>简而言之，接口关注的是行为的规范，而抽象类关注的是共享的属性。</p><h3 id="_6-重写和重载的区别" tabindex="-1"><a class="header-anchor" href="#_6-重写和重载的区别"><span>6. 重写和重载的区别</span></a></h3><p>重写（override）指的是子类重新实现了父类中已有的方法，子类的方法具有相同的名称、参数列表和返回类型。</p><p>重载（overload）指的是在同一个类中定义了多个方法，它们的方法名称相同但参数列表不同。</p><h3 id="_7-浅拷贝和深拷贝的区别" tabindex="-1"><a class="header-anchor" href="#_7-浅拷贝和深拷贝的区别"><span>7. 浅拷贝和深拷贝的区别</span></a></h3><p>浅拷贝：对象指针 地址相同</p><p>深拷贝：对象本身 地址不同</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324530.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324531.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>浅拷贝</strong>：浅拷贝只复制对象的指针而不复制对象本身,两个引用指针指向被复制对象(CloneObject1)的同一块引用地址</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，新老对象(CloneObject1,2)不共享内存</li></ul><h3 id="_8-值传递和引用传递的区别" tabindex="-1"><a class="header-anchor" href="#_8-值传递和引用传递的区别"><span>8. 值传递和引用传递的区别</span></a></h3><p>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。</p><p>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</p><p>一般认为,java 内的传递都是值传递. java 中实例对象的传递是引用传递。</p><h3 id="_9-io-流" tabindex="-1"><a class="header-anchor" href="#_9-io-流"><span>9. <a href="https://javaguide.cn/java/io/io-basis.html" target="_blank" rel="noopener noreferrer">IO 流</a></span></a></h3><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h3 id="_10-反射" tabindex="-1"><a class="header-anchor" href="#_10-反射"><span>10. 反射</span></a></h3><p>Java 的反射机制是指在运行时动态地获取类的信息并操作类或对象的能力。</p><p>通过反射，我们可以在编译时无法确定的情况下，通过类名获取类的实例、获取类的字段、方法、构造函数等信息，并且可以在运行时调用这些方法或访问这些字段。</p><p><strong>反射方法：</strong></p><ol><li><code>Class.forName(String className)</code>：根据类名获取对应的 Class 对象。</li><li><code>getClass()</code>：获取对象的运行时类型。</li><li><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：获取指定方法名和参数类型的方法。</li><li><code>getField(String name)</code>：获取指定名称的字段。</li><li><code>newInstance()</code>：使用默认的构造函数创建实例。</li><li><code>newInstance(Object... initargs)</code>：使用指定参数类型和值的构造函数创建实例。</li><li><code>invoke(Object obj, Object... args)</code>：调用指定对象的方法。</li></ol><h3 id="_11-sleep-和-wait-的区别" tabindex="-1"><a class="header-anchor" href="#_11-sleep-和-wait-的区别"><span>11. sleep 和 wait 的区别</span></a></h3><p>sleep：Thread类方法 不释放对象锁</p><p>wait：Object类方法 释放对象锁</p><p>sleep 是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用 sleep 不会释放对象锁。</p><p>wait 是 Object 类的方法，对此对象调用 wait 方法导致本线程释放对象锁，进入等待此对象的等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p><h3 id="_12-jvm-内存模型" tabindex="-1"><a class="header-anchor" href="#_12-jvm-内存模型"><span>12. JVM 内存模型</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324532.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324533.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324534.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Java 的内存结构主要包括方法区、堆、虚拟机栈、本地方法栈和程序计数器。方法区用于存储类信息，堆用于存储对象实例，虚拟机栈用于存储方法调用和局部变量，本地方法栈用于存储非 Java 方法信息，程序计数器用于记录当前线程执行的指令地址。</p><p><strong>堆：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324535.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>主要存放对象</li><li>新创建的对象都会放在堆上面</li><li>线程共享的</li><li>需要进行垃圾回收</li><li>如果内存不够、没有空间去分配给新创建的对象 =》OutOfMemoryError</li></ol><p><strong>堆的组成：</strong></p><ol><li>年轻代（eden + s0 + s1）</li></ol><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324536.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol start="2"><li>老年代</li></ol><p><strong>栈：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324537.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>虚拟机栈</li><li>线程私有的</li><li>栈里是一个个的栈帧（frame），每个栈帧对应一个被调用的方法</li></ol><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324538.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(1）局部变量表（local variables）</p><p>（2）操作数栈</p><p>（3）动态链接（调用的别的方法）</p><p>（4）返回地址和一些额外信息</p><ol start="4"><li>如果一个栈里的栈帧过多，就有可能出现stackoverflowError</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">( ){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>本地方法栈：</strong></p><ol><li>专门为了native本地方法使用</li><li>Java语言不能直接对操作系统底层进行访问和操作，所以需要通过JNI（Java Native Interface）去调用别的语言（C、C++、汇编）来实现对底层的访问</li><li>线程私有的</li></ol><p><strong>程序计数器：</strong></p><ol><li>线程私有的</li><li>存储当前线程执行的位置、行号</li><li>当线程切换，通过程序计数器知道从哪里重新运行</li></ol><p>**元空间（Metaspace）：**JDK8以后对JVM最大的一个调整</p><ol><li>保存类相关的信息：类的名字、方法名字、字段信息、静态变量</li><li>放在JVM外面</li></ol><p><strong>引起OOM的常见原因：</strong></p><ol><li><strong>Java Heap Space：</strong> 堆没有足够空间存放新创建的对象： （1）创建了超大对象，一般都是大数组。 调大堆的空间大小 （2）特殊场景：双11，超出预期的访问量、数据量。 双11 =》限流 （3）内存泄露：例子threadlocal，本来应该把它回收，但是没有回收成功，内存空间无法使用。 找bug</li><li><strong>GC Overhead limit exceeded：</strong>** **Java垃圾回收花费了非常多的时间进行垃圾回收，但是回收了一点点内存，并且这种情况已经连续重复了5次 说明可用的堆空间已经非常非常少了，GC也无能为力</li><li><strong>Metaspace：</strong>** **说明元空间满了，因为加载的类太多了</li><li><strong>Unable to create new native thread：</strong>** **因为创建的Java线程太多了，没有足够的资源进行分配了</li></ol><h3 id="_13-jvm-类加载器" tabindex="-1"><a class="header-anchor" href="#_13-jvm-类加载器"><span>13. JVM 类加载器</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324539.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>加载过程：</strong></p><ol><li>加载：通过类的全限定名获取字节码文件，并将其转换为方法区内的运行时数据结 构。</li><li>验证：对.class文件 里的字节码进行校验，确保符合 Java 虚拟机规范，能被执行。</li><li>准备：为类的静态变量分配内存，并设置默认初始值。</li><li>解析：将符号引用转换为直接引用，即将类、方法、字段等解析为具体的内存地址。</li><li>初始化：执行类的初始化代码，包括静态变量赋值和静态代码块的执行。</li></ol><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324540.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>分类：</strong></p><p>一、系统本身自带类加载器</p><p>（1）启动类加载器（Bootstrap classloader）</p><p>主要负责Java目录下核心类（lib目录，java中最核心的类库，支撑Java系统的运行）</p><p>（2）扩展类加载器（Extensions classloader）</p><p>lib/ext目录下的内容</p><p>（3）应用类加载器（Application classloader）</p><p>简单理解为加载程序员自己写好的代码</p><p>二、自定义类加载器</p><p>满足一些特殊需求，需要继承 java.lang.ClassLoader 来实现</p><h3 id="_14-jvm-双亲委派机制" tabindex="-1"><a class="header-anchor" href="#_14-jvm-双亲委派机制"><span>14. JVM 双亲委派机制</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324541.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>双亲委派机制是指类加载器在加载类时，首先将加载请求委托给父类加载器，只有当父类加载器无法加载时，才自己尝试加载。从而确保类的加载安全和防止类的重复加载。</p><p>java.lang.Object，它是放在rt.jar之中，它永远都会被最上面的加载器进行加载，因此无论在任何环境下，都能找到这个类</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324542.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>不同classloader加载的类肯定是不相同的，相当于在JVM当中创建了一个个互相隔离的空间，这种技术在框架中经常被使用</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324543.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_15-jvm-垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_15-jvm-垃圾回收算法"><span>15. JVM 垃圾回收算法</span></a></h3><p>（1）**标记 - 清理：**导致内存碎片</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324544.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>（2）**标记 - 整理：**释放完空间后，会对整个内存空间进行整理，去除内存碎片</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324545.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>缺点：整理的过程非常慢，非常耗资源</p><p>（3）**复制 - 清理：**先标记哪些需要被删除，哪些需要被复制</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324546.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>缺点：空间只能用一半</p><h2 id="二、集合" tabindex="-1"><a class="header-anchor" href="#二、集合"><span>二、集合</span></a></h2><h3 id="_1-java-常用的集合、分类、接口" tabindex="-1"><a class="header-anchor" href="#_1-java-常用的集合、分类、接口"><span>1. Java 常用的集合、分类、接口</span></a></h3><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。</p><p>Java 集合框架如下图所示：</p><p><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324547.png" alt="img" loading="lazy"><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324548.jpeg" alt="img" loading="lazy"></p><p><strong>实现类：</strong></p><ul><li><strong>List</strong>：ArrayList 是基于数组的动态列表，LinkedList 是基于链表的列表，Vector 是线程安全的列表。</li><li><strong>Set</strong>：HashSet 是基于哈希表的集合，LinkedHashSet 是基于哈希表和链表的集合，TreeSet 是基于红黑树的有序集合。</li><li><strong>Map</strong>：HashMap 是基于哈希表的映射，LinkedHashMap 是基于哈希表和链表的映射，TreeMap 是基于红黑树的有序映射。</li><li><strong>Queue</strong>：LinkedList 可以作为队列使用，PriorityQueue 是基于优先级的队列。</li></ul><h3 id="_2-arraylist-和-array-数组-的区别" tabindex="-1"><a class="header-anchor" href="#_2-arraylist-和-array-数组-的区别"><span>2. ArrayList 和 Array（数组）的区别</span></a></h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h3 id="_3-arraylist-与-linkedlist-区别" tabindex="-1"><a class="header-anchor" href="#_3-arraylist-与-linkedlist-区别"><span>3. ArrayList 与 LinkedList 区别</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324549.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>ArrayList 基于动态数组实现，查询操作快。</p><p>LinkedList基于双向链表实现，增删操作快。</p><details class="lake-collapse"><summary id="u5ec6a050"><span class="ne-text" style="font-size:16px;">array 用的比 linked 更多 </span></summary><p id="u6ee568b3" class="ne-p" style="margin:0;padding:0;min-height:24px;"><span class="ne-text" style="font-size:16px;">我们在项目中一般是不会使用到 </span><code class="ne-code" style="font-family:SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;background-color:rgba(0, 0, 0, 0.06);border:1px solid rgba(0, 0, 0, 0.08);border-radius:2px;padding:0px 2px;"><span class="ne-text" style="font-size:16px;">LinkedList</span></code><span class="ne-text" style="font-size:16px;"> 的，需要用到 </span><code class="ne-code" style="font-family:SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;background-color:rgba(0, 0, 0, 0.06);border:1px solid rgba(0, 0, 0, 0.08);border-radius:2px;padding:0px 2px;"><span class="ne-text" style="font-size:16px;">LinkedList</span></code><span class="ne-text" style="font-size:16px;"> 的场景几乎都可以使用 </span><code class="ne-code" style="font-family:SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;background-color:rgba(0, 0, 0, 0.06);border:1px solid rgba(0, 0, 0, 0.08);border-radius:2px;padding:0px 2px;"><span class="ne-text" style="font-size:16px;">ArrayList</span></code><span class="ne-text" style="font-size:16px;"> 来代替，并且，性能通常会更好！就连 </span><code class="ne-code" style="font-family:SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;background-color:rgba(0, 0, 0, 0.06);border:1px solid rgba(0, 0, 0, 0.08);border-radius:2px;padding:0px 2px;"><span class="ne-text" style="font-size:16px;">LinkedList</span></code><span class="ne-text" style="font-size:16px;"> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 </span><code class="ne-code" style="font-family:SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;background-color:rgba(0, 0, 0, 0.06);border:1px solid rgba(0, 0, 0, 0.08);border-radius:2px;padding:0px 2px;"><span class="ne-text" style="font-size:16px;">LinkedList</span></code><span class="ne-text" style="font-size:16px;"> 。</span></p><p id="u639b5f4e" class="ne-p" style="margin:0;padding:0;min-height:24px;"><img src="https://cdn.nlark.com/yuque/0/2024/png/33541132/1729769549577-09684522-be7f-4798-bec3-33c5f8c9a7ca.png" width="1069" id="xlmmH" class="ne-image" style="font-size:16px;"></p><p id="uc57a9cc7" class="ne-p" style="margin:0;padding:0;min-height:24px;"><span class="ne-text" style="font-size:16px;">另外，不要下意识地认为 </span><code class="ne-code" style="font-family:SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;background-color:rgba(0, 0, 0, 0.06);border:1px solid rgba(0, 0, 0, 0.08);border-radius:2px;padding:0px 2px;"><span class="ne-text" style="font-size:16px;">LinkedList</span></code><span class="ne-text" style="font-size:16px;"> 作为链表就最适合元素增删的场景。我在上面也说了，</span><code class="ne-code" style="font-family:SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;background-color:rgba(0, 0, 0, 0.06);border:1px solid rgba(0, 0, 0, 0.08);border-radius:2px;padding:0px 2px;"><span class="ne-text" style="font-size:16px;">LinkedList</span></code><span class="ne-text" style="font-size:16px;"> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。</span></p></details><h3 id="_4-hashset、linkedhashset-和-treeset-异同" tabindex="-1"><a class="header-anchor" href="#_4-hashset、linkedhashset-和-treeset-异同"><span>4. HashSet、LinkedHashSet 和 TreeSet 异同</span></a></h3><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都是线程不安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。</li></ul><p><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数 据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑 树，元素是有序的，排序的方式有自然排序和定制排序。</p><ul><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h3 id="_5-hashmap-底层原理" tabindex="-1"><a class="header-anchor" href="#_5-hashmap-底层原理"><span>5. HashMap 底层原理</span></a></h3><p><strong>关键属性：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324550.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>第一个属性 loadFactor，它是负载因子，默认值是0.75，表示扩容前 。</p><p>第二个属性 threshold 它是记录HashMap所能容纳的键值对的临界值，它的计算规则是负载因子 × 数组长度，扩容后的容量为当前容量的 2 倍。例如，初始容量为16，当元素数量达到 12 时会触发扩容，扩容后的容量为 32。</p><p>第三个属性size，它用来记录HashMap实际存在的键值对的数量。</p><p>第四个属性modCount，它用来记录HashMap内部结构修改的次数。</p><p>第五个是常量属性DEFAULT_INITIAL_CAPACITY ，它规定的默认容量是16。</p><p><strong>存储结构：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324551.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>HashMap采用的是哈希表（散列表）的存储结构。HashMap的数组部分称为Hash桶，数组元素保存在一个叫做table的属性中。当链表长度大于等于8时，链表数据将会以红黑树的形式进行存储，当长度降到6时，又会转成链表形式存储。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324552.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>每个Node节点，保存了用来定位数组索引位置的hash值、Key、Value和链表指向的下一个Node节点。而Node类是HashMap的内部类，它实现了Map.Entry接口，它的本质其实可以简单的理解成就是一个键值对。</p><h3 id="_6-concurrenthashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#_6-concurrenthashmap-和-hashtable-的区别"><span>6. ConcurrentHashMap 和 Hashtable 的区别</span></a></h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><p>ConcurrentHashMap:</p><p>• 底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p><p>• 实现线程安全的方式（重要）：</p><p>◦ 在 JDK1.7 的时候，ConcurrentHashMap 对整个桶数组进行了分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p><p>◦ 到了 JDK1.8 的时候，ConcurrentHashMap 已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p><p>Hashtable(同一把锁) :</p><p>使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p><p>下面，我们再来看看两者底层数据结构的对比图。</p><p><strong>Hashtable :</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324553.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324554.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Java7 ConcurrentHashMap 存储结构：</strong></p><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</p><p>Segment 数组中的每个元素包含一个 HashEntry 数组，每个 HashEntry 数组属于链表结构。</p><p>JDK1.8 的 ConcurrentHashMap：</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324555.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Java8 ConcurrentHashMap 存储结构：</strong></p><p>JDK1.8 的 ConcurrentHashMap 不再是 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。当冲突链表达到一定长度时，链表会转换成红黑树。</p><p>TreeNode是存储红黑树节点，被TreeBin包装。TreeBin通过root属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 ConcurrentHashMap 中TreeBin通过waiter属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TreeBin</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    TreeNode</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TreeNode</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> first</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> waiter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lockState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // values for lockState</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> WRITER </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // set while holding write lock</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> WAITER </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // set when waiting for write lock</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> READER </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // increment value for setting read lock</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-concurrenthashmap-线程安全的具体实现方式-底层具体实现" tabindex="-1"><a class="header-anchor" href="#_7-concurrenthashmap-线程安全的具体实现方式-底层具体实现"><span>7. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</span></a></h3><p><strong>JDK1.8 之前：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324556.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Java7 ConcurrentHashMap 存储结构:</p><p>首先将数据分为一段一段（这个“段”就是 Segment）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</p><p>Segment 继承了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Segment</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ReentrantLock</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Serializable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的个数一旦初始化就不能改变。 Segment数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p><p>Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。也就是说，对同一 Segment 的并发写入会被阻塞，不同 Segment 的写入是可以并发执行的。</p><p><strong>JDK1.8 之后：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324557.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Java8 ConcurrentHashMap 存储结构：</p><p>Java 8 几乎完全重写了 <code>ConcurrentHashMap</code>，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。</p><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，Node 数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p><p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p><h3 id="_8-jdk-1-7-和-jdk-1-8-的-concurrenthashmap-实现有什么不同" tabindex="-1"><a class="header-anchor" href="#_8-jdk-1-7-和-jdk-1-8-的-concurrenthashmap-实现有什么不同"><span>8. JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</span></a></h3><ul><li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li><li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值（8）时，将链表转换为红黑树）。</li><li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h2 id="三、并发" tabindex="-1"><a class="header-anchor" href="#三、并发"><span>三、并发</span></a></h2><h3 id="_1-线程和进程的区别" tabindex="-1"><a class="header-anchor" href="#_1-线程和进程的区别"><span>1. 线程和进程的区别</span></a></h3><p>进程：</p><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（<code>.exe</code> 文件的运行）。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324558.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>线程：</p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MultiThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		// 获取 Java 线程管理 MXBean</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">	ThreadMXBean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> threadMXBean</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> ManagementFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getThreadMXBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">		ThreadInfo</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">threadInfos</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> threadMXBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">dumpAllThreads</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">		for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ThreadInfo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> threadInfo</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> threadInfos) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">			System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;[&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> threadInfo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getThreadId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;] &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> threadInfo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getThreadName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">		}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Attach</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> Listener </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//添加事件</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Signal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> Dispatcher </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 分发处理给 JVM 信号的线程</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] Finalizer </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//调用对象 finalize 方法的线程</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Reference</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> Handler </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//清除 reference 线程</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] main </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//main 线程,程序入口</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324559.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Java 运行时数据区域（JDK1.8 之后）从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。</p><p>总结：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h3 id="_2-创建线程的方式" tabindex="-1"><a class="header-anchor" href="#_2-创建线程的方式"><span>2. 创建线程的方式</span></a></h3><ol><li>继承 Thread 类：</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 定义一个继承自 Thread 类的线程类</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyThread</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 线程执行的代码</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Thread running&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 创建线程实例，并启动线程</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        MyThread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> thread</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MyThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>实现 Runnable 接口：</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 定义一个实现 Runnable 接口的线程类</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyRunnable</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Runnable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 线程执行的代码</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Thread running&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 创建线程实例，并启动线程</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        MyRunnable</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> runnable</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MyRunnable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> thread</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(runnable);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>使用匿名内部类：</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> thread</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Runnable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 线程执行的代码</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Thread running&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>使用 Lambda 表达式：</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> thread</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Thread running&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-线程的生命周期和状态" tabindex="-1"><a class="header-anchor" href="#_3-线程的生命周期和状态"><span>3. 线程的生命周期和状态</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324560.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>• NEW: 初始状态，线程被创建出来但没有被调用 start() 。</p><p>• RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。</p><p>• BLOCKED：阻塞状态，需要等待锁释放。</p><p>• WAITING：等待状态，线程进入等待状态，直到其他线程显式地唤醒它。线程可以调用 Object 类的 wait()方法、join()方法或 Lock 类的条件等待方法进入此状态。</p><p>• TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p><p>• TERMINATED：终止状态，表示该线程已经运行完毕。</p><h3 id="_4-线程上下文切换" tabindex="-1"><a class="header-anchor" href="#_4-线程上下文切换"><span>4. 线程上下文切换</span></a></h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><p>• 主动让出 CPU，比如调用了 sleep(), wait() 等。</p><p>• 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</p><p>• 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</p><p>• 被终止或结束运行</p><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，等待线程下次占用 CPU 的时候恢复现场，并加载下一个将要占用 CPU 的线程上下文。这就是所谓的上下文切换。</p><h3 id="_5-sleep-和-wait-方法对比" tabindex="-1"><a class="header-anchor" href="#_5-sleep-和-wait-方法对比"><span>5. sleep() 和 wait() 方法对比</span></a></h3><p>共同点：两者都可以暂停线程的执行。</p><p>区别：</p><p>• sleep() 方法没有释放锁，而 wait() 方法释放了锁 。</p><p>• wait() 通常被用于线程间交互/通信，sleep()通常被用于暂停执行。</p><p>• wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。| sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。</p><p>• sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。</p><h3 id="_6-并发与并行的区别" tabindex="-1"><a class="header-anchor" href="#_6-并发与并行的区别"><span>6. 并发与并行的区别</span></a></h3><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行。</p><h3 id="_7-同步和异步的区别" tabindex="-1"><a class="header-anchor" href="#_7-同步和异步的区别"><span>7. 同步和异步的区别</span></a></h3><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><h3 id="_8-线程调度方式" tabindex="-1"><a class="header-anchor" href="#_8-线程调度方式"><span>8. 线程调度方式</span></a></h3><ul><li><strong>抢占式调度（Preemptive Scheduling）</strong>：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。这种切换通常是由系统时钟中断（时间片轮转）或其他高优先级事件（如 I/O 操作完成）触发的。这种方式存在上下文切换开销，但公平性和 CPU 资源利用率较好，不易阻塞。</li><li><strong>协同式调度（Cooperative Scheduling）</strong>：线程执行完毕后，主动通知系统切换到另一个线程。这种方式可以减少上下文切换带来的性能开销，但公平性较差，容易阻塞。</li></ul><p>Java 使用的线程调度是抢占式的。也就是说，JVM 本身不负责线程的调度，而是将线程的调度委托给操作系统。操作系统通常会基于线程优先级和时间片来调度线程的执行，高优先级的线程通常获得 CPU 时间片的机会更多。</p><h3 id="_9-死锁" tabindex="-1"><a class="header-anchor" href="#_9-死锁"><span>9. 死锁</span></a></h3><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html" target="_blank" rel="noopener noreferrer">Java并发常见面试题总结（上）</a></p><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="_10-jmm" tabindex="-1"><a class="header-anchor" href="#_10-jmm"><span>10. JMM</span></a></h3><p>Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。</p><p>JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p><p>JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性、有序性、可见性展开的。它描述了主内存与工作内存的交互操作，如：lock、unlock、read、load、use、assign、store和write，并设定了这些操作的执行规则，以保证并发程序的正确性。</p><h3 id="_11-可见性" tabindex="-1"><a class="header-anchor" href="#_11-可见性"><span>11. 可见性</span></a></h3><p>一个线程修改了共享变量的值，其他线程能够看到修改的值。</p><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的。</p><p>如何保证可见性</p><p>通过 volatile 关键字保证可见性。</p><p>通过 内存屏障 保证可见性。</p><p>通过 synchronized 关键字保证可见性。</p><p>通过 Lock 保证可见性。</p><p>通过 final 关键字保证可见性</p><h3 id="_12-有序性" tabindex="-1"><a class="header-anchor" href="#_12-有序性"><span>12. 有序性</span></a></h3><p>程序执行的顺序按照代码的先后顺序执行。JVM 存在指令重排，所以存在有序性问题。</p><p>如何保证有序性</p><p>通过 volatile 关键字保证有序性。</p><p>通过 内存屏障保证有序性。</p><p>通过 synchronized 关键字保证有序性。</p><p>通过 Lock 保证有序性。</p><h3 id="_13-原子性" tabindex="-1"><a class="header-anchor" href="#_13-原子性"><span>13. 原子性</span></a></h3><p>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。</p><p>在 Java中，对基本数据类型的变量的读取和赋值操作是原子性操作（64位处理器）。不采取任何的原子性保障措施的自增操作并不是原子性的。</p><p>如何保证原子性</p><p>通过 synchronized 关键字保证原子性。</p><p>通过 Lock 保证原子性。</p><p>通过 CAS 保证原子性。</p><h3 id="_14-cas" tabindex="-1"><a class="header-anchor" href="#_14-cas"><span>14. <a href="https://blog.csdn.net/u012581020/article/details/132165800" target="_blank" rel="noopener noreferrer">CAS</a></span></a></h3><p>CAS（Compare and Swap）比较与交换是一种并发编程中常用的技术，用于解决多线程环境下的并发访问问题。CAS操作是一种原子操作，它可以提供线程安全，避免了使用传统锁机制所带来的性能开销。</p><p>实现线程安全的并发控制：CAS操作可以保证在多线程环境中对共享数据进行原子性的读写操作，从而避免了多线程并发访问时可能引发的数据不一致问题。它提供了一种基于硬件层面的并发控制机制。</p><p>提高性能和可伸缩性：相比于传统的锁机制，CAS操作<strong>不需要</strong>阻塞线程或切换上下文，因为它是一种乐观锁机制。这使得CAS在高并发场景下具有更好的性能和可伸缩性，尤其适用于细粒度的并发控制。</p><p>解决ABA问题：CAS操作使用期望值来判断共享数据是否被修改过，但它无法检测到共享数据在操作过程中经历了多次修改，然后又回到了期望值的情况，即ABA问题。为了解决ABA问题，可以使用版本号、引用更新等技术。</p><p>支持无锁算法：CAS操作可以用于实现一些无锁算法，如非阻塞数据结构和并发容器。无锁算法可以避免线程间的竞争和阻塞，提高程序的吞吐量和效率。</p><p>并发数据结构中的应用：CAS操作在并发数据结构中得到广泛应用，如高性能队列、计数器、散列表等。它可以保证多个线程同时对共享数据进行读写时的一致性和正确性。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324561.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324562.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_15-volatile-关键字" tabindex="-1"><a class="header-anchor" href="#_15-volatile-关键字"><span>15. volatile 关键字</span></a></h3><ol><li>volatile保证了可见性、有序性</li><li>volatile不支持原子性，适用于读多写少的场景</li></ol><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324563.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>实现可见性：</p><p><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324564.png" alt="img" loading="lazy"><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324565.png" alt="img" loading="lazy"></p><p>实现有序性：</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324566.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>使用场景</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324567.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_16-synchronized-关键字" tabindex="-1"><a class="header-anchor" href="#_16-synchronized-关键字"><span>16. synchronized 关键字</span></a></h3><p><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>保证原子性：</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324568.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324569.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>底层原理：</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324570.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> StockSample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 商品的库存一共十万件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stockCount </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //模拟一直在进行卖出，每卖出一件将对商品的库存减1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i++){</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            stockCount--;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[]</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        StockSample</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sample</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> StockSample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 线程1</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            sample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 线程2</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            sample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 等待两个线程执行结束</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            t1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(stockCount);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">printStackTrace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用方法：</p><ol><li>修饰一个实例的方法</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> StockSample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 商品的库存一共十万件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stockCount </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //模拟一直在进行卖出，每卖出一件将对商品的库存减1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i++){</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            stockCount--;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[]</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        StockSample</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sample</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> StockSample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 线程1</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            sample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 线程2</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            sample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 等待两个线程执行结束</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            t1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(stockCount);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">printStackTrace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>修饰一个类方法</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> StockSample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 商品的库存一共十万件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stockCount </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //模拟一直在进行卖出，每卖出一件将对商品的库存减1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i++){</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            stockCount--;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[]</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // StockSample sample = new StockSample();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 线程1</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            StockSample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 线程2</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            StockSample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 等待两个线程执行结束</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            t1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(stockCount);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">printStackTrace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>修饰一个代码块</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> StockSample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 商品的库存一共十万件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stockCount </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // private static volatile int value;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // get value</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 模拟一直在进行卖出，每卖出一件将对商品的库存减1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i++) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                stockCount--;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // StockSample sample = new StockSample();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 线程1</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            sample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 线程2</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            sample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">deduct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 等待两个线程执行结束</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            t1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(stockCount);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">printStackTrace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优化：</p><p>在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p><p>关于偏向锁多补充一点：由于偏向锁增加了 JVM 的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK15 中，偏向锁被默认关闭（仍然可以使用 <code>-XX:+UseBiasedLocking</code> 启用偏向锁），在 JDK18 中，偏向锁已经被彻底废弃（无法通过命令行打开）。</p><h3 id="_17-synchronized-和-volatile-区别" tabindex="-1"><a class="header-anchor" href="#_17-synchronized-和-volatile-区别"><span>17. synchronized 和 volatile 区别</span></a></h3><ul><li><code>volatile</code> 关键字是线程同步的轻量级实现，<code>synchronized</code>关键字是线程同步的重量级实现。</li><li><code>volatile</code> 关键字只能用于变量而，<code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><code>volatile</code> 关键字能保证数据的可见性，<code>synchronized</code> 关键字能保证数据的可见性和原子性。</li><li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h3 id="_18-aqs" tabindex="-1"><a class="header-anchor" href="#_18-aqs"><span>18. AQS</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324571.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>竞争锁：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324572.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>可重入锁：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324573.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>释放锁：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324574.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324575.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_19-reentrantlock" tabindex="-1"><a class="header-anchor" href="#_19-reentrantlock"><span>19. ReentrantLock</span></a></h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ReentrantLock</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Lock</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> java.io.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Serializable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324576.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ReentrantLock</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">boolean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fair) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">sync </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fair </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FairSync</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> NonfairSync</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_20-公平锁和非公平锁的区别" tabindex="-1"><a class="header-anchor" href="#_20-公平锁和非公平锁的区别"><span>20. 公平锁和非公平锁的区别</span></a></h3><ul><li><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h3 id="_21-synchronized-和-lock-的区别" tabindex="-1"><a class="header-anchor" href="#_21-synchronized-和-lock-的区别"><span>21. synchronized 和 lock 的区别<img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324577.png" alt="img" loading="lazy"></span></a></h3><p>synchronized 是 Java 关键字，是内置的同步机制，能修饰方法或代码块，锁的获取是隐式的，底层实现原理是基于 JVM内置监视器锁；</p><p>Lock 是一个接口，提供更灵活的同步机制，可以手动控制锁的获取和释放，底层实现可以是 ReentrantLock 等，性能在高竞争环境下通常较好。</p><h3 id="_22-synchronized-和-reentrantlock-对比" tabindex="-1"><a class="header-anchor" href="#_22-synchronized-和-reentrantlock-对比"><span>22. synchronized 和 ReentrantLock 对比</span></a></h3><p><strong>两者都是可重入锁：</strong></p><p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p><p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p><p>在下面的代码中，<code>method1()</code> 和 <code>method2()</code>都被 <code>synchronized</code> 关键字修饰，<code>method1()</code>调用了<code>method2()</code>。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> SynchronizedDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> method1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;方法1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        method2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> method2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;方法2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 <code>synchronized</code>锁是可重入的，同一个线程在调用<code>method1()</code> 时可以直接获得当前对象的锁，执行 <code>method2()</code> 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如<code>synchronized</code>是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 <code>method2()</code>时获取锁失败，会出现死锁问题。</p><p><strong>synchronized</strong> <strong>依赖于</strong> <strong>JVM</strong> <strong>而</strong> <strong>ReentrantLock</strong> <strong>依赖于</strong> <strong>API：</strong></p><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p><p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>ReentrantLock 比 synchronized 增加了一些高级功能：</strong></p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><h3 id="_23-可中断锁和不可中断锁的区别" tabindex="-1"><a class="header-anchor" href="#_23-可中断锁和不可中断锁的区别"><span>23. 可中断锁和不可中断锁的区别</span></a></h3><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</li></ul><h3 id="_24-atomic-原子类" tabindex="-1"><a class="header-anchor" href="#_24-atomic-原子类"><span>24. <a href="https://javaguide.cn/java/concurrent/atomic-classes.html#atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener noreferrer">Atomic 原子类</a></span></a></h3><p>原子类简单来说就是具有原子性操作特征的类。</p><p><code>java.util.concurrent.atomic</code> 包中的 <code>Atomic</code> 原子类提供了一种线程安全的方式来操作单个变量。</p><p><code>Atomic</code> 类依赖于 CAS（Compare-And-Swap，比较并交换）乐观锁来保证其方法的原子性，而不需要使用传统的锁机制（如 <code>synchronized</code> 块或 <code>ReentrantLock</code>）。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324578.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_25-threadlocal-原理" tabindex="-1"><a class="header-anchor" href="#_25-threadlocal-原理"><span>25. ThreadLocal 原理</span></a></h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现<strong><strong>每一个线程都有自己的专属本地变量</strong></strong>该如何解决呢？</strong></p><p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <code>**ThreadLocal**</code><strong>类主要解决的就是让<strong><strong>每个线程绑定自己的值</strong></strong>，可以将</strong><code>**ThreadLocal**</code><strong>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据</strong>**。**</p><p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><p>再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p><h3 id="_26-threadlocal-内存泄露" tabindex="-1"><a class="header-anchor" href="#_26-threadlocal-内存泄露"><span>26. ThreadLocal 内存泄露</span></a></h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。</p><p><code>ThreadLocal</code> 在没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p><h3 id="_27-线程池的核心参数" tabindex="-1"><a class="header-anchor" href="#_27-线程池的核心参数"><span>27. 线程池的核心参数</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ThreadPoolExecutor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> corePoolSize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 线程池的核心线程数量</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                          int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> maximumPoolSize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 线程池的最大线程数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                          long</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> keepAliveTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                          TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> unit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 时间单位</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                          BlockingQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Runnable</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> workQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 任务队列，用来储存等待执行任务的队列</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                          ThreadFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> threadFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 线程工厂，用来创建线程，一般默认即可</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                          RejectedExecutionHandler</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> handle) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_28-线程池的创建" tabindex="-1"><a class="header-anchor" href="#_28-线程池的创建"><span>28. 线程池的创建</span></a></h3><p><strong>方式一：</strong><code>**ThreadPoolExecutor**</code><strong>构造函数（推荐）</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324579.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>方式二：spring 的</strong> <code>**ThreadPoolTaskExecutor** </code></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324580.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>创建线程池需要合理配置线程池的大小、选择适当的任务队列和拒绝策略，正确管理线程池的生命周期，并考虑线程安全性。</p><h3 id="_29-线程池工作原理" tabindex="-1"><a class="header-anchor" href="#_29-线程池工作原理"><span>29. 线程池工作原理</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324581.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p><p>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><p> 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p><p> 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p><p> 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p><p> 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。</p><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><h3 id="_30-线程池的拒绝策略" tabindex="-1"><a class="header-anchor" href="#_30-线程池的拒绝策略"><span>30. 线程池的拒绝策略</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324582.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>线程池的拒绝策略有四种：AbortPolicy（默认方式，中止并抛出RejectedExecutionException 异常）、CallerRunsPolicy（使用调用线程来执行被拒绝的任务）、DiscardPolicy（默默地丢弃拒绝的任务）以及 DiscardOldestPolicy（丢弃最早被添加到队列的任务，然后尝试重新提交新任务）。</p><p>如果希望快速失败并将异常传递给调用者，则选择 AbortPolicy。如果希望尽可能保证任务的执行</p><p>而不堆积在队列中，则选择 CallerRunsPolicy。如果对任务的丢失情况不敏感，则选择DiscardPolicy。而如果希望尽可能保留最新的任务而不是旧的任务，则选择DiscardOldestPolicy。</p><h3 id="_31-countdownlatch" tabindex="-1"><a class="header-anchor" href="#_31-countdownlatch"><span>31. CountDownLatch</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324583.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324584.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324585.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_32-cyclicbarrier" tabindex="-1"><a class="header-anchor" href="#_32-cyclicbarrier"><span>32. CyclicBarrier</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324586.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324587.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324588.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_33-countdownlatch-和-cyclicbarrier-区别" tabindex="-1"><a class="header-anchor" href="#_33-countdownlatch-和-cyclicbarrier-区别"><span>33. CountDownLatch 和 CyclicBarrier 区别</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324589.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_34-semaphore" tabindex="-1"><a class="header-anchor" href="#_34-semaphore"><span>34. Semaphore</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324590.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324591.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Semaphore 模型：</strong></p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324592.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324593.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_35-arrayblockingqueue" tabindex="-1"><a class="header-anchor" href="#_35-arrayblockingqueue"><span>35. ArrayBlockingQueue</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324594.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_36-linkedbloackingqueue" tabindex="-1"><a class="header-anchor" href="#_36-linkedbloackingqueue"><span>36. LinkedBloackingQueue</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324595.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_37-悲观锁和乐观锁的区别" tabindex="-1"><a class="header-anchor" href="#_37-悲观锁和乐观锁的区别"><span>37. <a href="https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html" target="_blank" rel="noopener noreferrer">悲观锁和乐观锁的区别</a></span></a></h3><p>悲观锁：认为自己在使用数据的时候一定有别的线程来修改数据，在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p>实现：关键字 synchronized、接口 Lock 的实现类</p><p>适用场景：写操作较多，先加锁可以保证写操作时数据正确</p><p>乐观锁：认为自己使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。</p><p>实现 ：</p><ul><li>CAS 算法， CAS 即 Compare And Swap，是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则返回 false，不进行任何操作；例如：ActomicInteger 类的原子自增是通过 CAS 自选实现。</li><li>版本号控制：数据表中加上版本号字段 version，表示数据被修改的次数。当数据被修改时，这个字段值会加 1，提交必 须满足“ 提交版本必须大于记录当前版本才能执行更新“的乐观锁策略。</li></ul><p>适用场景：读操作较多，不加锁的特点能够使其读操作的性能大幅提升</p><h2 id="四、设计模式" tabindex="-1"><a class="header-anchor" href="#四、设计模式"><span>四、设计模式</span></a></h2><h3 id="_1-分类" tabindex="-1"><a class="header-anchor" href="#_1-分类"><span>1. 分类</span></a></h3><p><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324596.jpeg" alt="img" loading="lazy"><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324597.png" alt="img" loading="lazy"></p><p>创建型： 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括⼯⼚/抽象⼯⼚/单例/建造者/原型模式。</p><p>结构型： 通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。包括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。</p><p>⾏为型： 通过类之间不同通信⽅式实现不同⾏为。包括责任链/命名/解释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式。</p><h3 id="_2-工厂模式" tabindex="-1"><a class="header-anchor" href="#_2-工厂模式"><span>2. 工厂模式</span></a></h3><p>和简单⼯⼚模式中⼯⼚负责⽣产所有产品相⽐，⼯⼚⽅法模式将⽣成具体产品的任务分发给具体的产品⼯⼚。</p><p>UML 类图如下：</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324598.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>也就是定义⼀个抽象⼯⼚，其定义了产品的⽣产接⼝，但不负责具体的产品，将⽣产任务交给不同的派⽣类⼯⼚。这样不⽤通过指定类型来创建对象了。</p><h3 id="_3-单例模式" tabindex="-1"><a class="header-anchor" href="#_3-单例模式"><span>3. 单例模式</span></a></h3><p>单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例，构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀个静态公有⽅法获取实例。 优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的情况下并且可以避免对资源的多重占⽤。缺点是没有抽象层，难以扩展，与单⼀职责原则冲突。</p><h3 id="_4-代理模式" tabindex="-1"><a class="header-anchor" href="#_4-代理模式"><span>4. 代理模式</span></a></h3><p>代理模式的本质是⼀个中间件，主要⽬的是解耦合服务提供者和使⽤者。使⽤者通过代理间接的访问服务提供者，便于后者的封装和控制。是⼀种结构性模式。</p><p>下⾯是 GoF 介绍典型的代理模式 UML 类图</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324599.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Subject:</strong> 定义 RealSubject 对外的接⼝，且这些接⼝必须被 Proxy 实现，这样外部调⽤ proxy 的接⼝最终都被转化为对 realsubject 的调⽤。</p><p><strong>RealSubject:</strong> 真正的⽬标对象。</p><p><strong>Proxy:</strong> ⽬标对象的代理，负责控制和管理⽬标对象，并间接地传递外部对⽬标对象的访问。</p><p>Remote Proxy: 对本地的请求以及参数进⾏序列化，向远程对象发送请求，并对响应结果进⾏反序列化，将最终结果反馈给调⽤者；</p><p>Virtual Proxy: 当⽬标对象的创建开销⽐较⼤的时候，可以使⽤延迟或者异步的⽅式创建⽬标对象；</p><p>Protection Proxy: 细化对⽬标对象访问权限的控制；</p><h3 id="_5-策略模式" tabindex="-1"><a class="header-anchor" href="#_5-策略模式"><span>5. 策略模式</span></a></h3><p>策略模式（Strategy Pattern）属于对象的⾏为模式。其⽤意是针对⼀组算法，将每⼀个算法封装到具有共同接⼝的独⽴的类中，从⽽使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发⽣变化。其主要⽬的是通过定义相似的算法，替换 if else 语句写法，并且可以随时相互替换。</p><h3 id="_6-spring-框架中用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_6-spring-框架中用到了哪些设计模式"><span>6. Spring 框架中用到了哪些设计模式？</span></a></h3><ul><li><strong>工厂****设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理****设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例****设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板****方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器****设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者****模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器****模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h3 id="_7-mybatis-中有哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_7-mybatis-中有哪些设计模式"><span>7. MyBatis 中有哪些设计模式</span></a></h3><p>工厂模式，例如 SqlSessionFactory、ObjectFactory、MapperProxyFactory；</p><p>单例模式，例如 ErrorContext 和 LogFactory；</p><p>代理模式，Mybatis 实现的核心，比如 MapperProxy、ConnectionLogger，</p><p>用的 jdk 的动态代理；还有 executor.loader 包使用了 cglib 或者 javassist 达</p><p>到延迟加载的效果；</p><h2 id="五、mysql" tabindex="-1"><a class="header-anchor" href="#五、mysql"><span>五、MySQL</span></a></h2><h3 id="_1-事务" tabindex="-1"><a class="header-anchor" href="#_1-事务"><span>1. 事务</span></a></h3><p>数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：要么全部执行成功,要么全部不执行 。</p><div class="language-plsql line-numbers-mode" data-highlighter="shiki" data-ext="plsql" data-title="plsql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 开启一个事务</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">START TRANSACTION;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 多条 </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SQL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 语句</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SQL1,SQL2...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">## 提交事务</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">COMMIT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-acid-特性" tabindex="-1"><a class="header-anchor" href="#_2-acid-特性"><span>2. ACID 特性</span></a></h3><ol><li>原子性（Atomicity）：事务中的操作要么全部成功，要么全部失败。</li></ol><p>事务是一个不可分割的单元，要么全部执行，要么全部回滚。如果事务中的任何操作失败，所有操作都将被回滚到事务开始之前的状态，以保证数据的一致性。</p><ol start="2"><li>一致性（Consistency）：事务的执行应使数据库从一个一致性状态转移到另一个一致性状态。</li></ol><p>在事务开始和结束时，数据库的完整性约束应得到满足，确保数据的正确性和一致性。</p><ol start="3"><li>隔离性（Isolation）：每个事务在执行过程中都应该与其他事务隔离。</li></ol><p>并发事务的执行应当互不干扰，每个事务应该感知不到其他事务的存在或并发执行。隔离级别定义了不同事务之间的可见性和互相影响的程度。</p><ol start="4"><li>持久性（Durability）：一旦事务提交成功，其对数据库的修改应该永久保存。</li></ol><p>即使系统发生故障或重启，也应该能够保持数据的持久性。</p><h3 id="_3-隔离级别" tabindex="-1"><a class="header-anchor" href="#_3-隔离级别"><span>3. 隔离级别</span></a></h3><ul><li><strong>READ-UNCOMMITTED(读未提交)</strong> ：允许读取尚未提交的数据变更，</li></ul><p>最低的隔离级别，可能会导致脏读、幻读或不可重复读。</p><ul><li><strong>READ-COMMITTED(读已提交)</strong> ：允许读取并发事务已经提交的数据，</li></ul><p>可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p><ul><li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，</li></ul><p>除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><ul><li><strong>SERIALIZABLE(串行化)</strong> ：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，</li></ul><p>最高的隔离级别，完全服从 ACID 的隔离级别。也就是说，该级别可以防止脏读、不可重复读 以及幻读。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED**(读未提交)**</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED**(读已提交)**</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ**(可重复读)**</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE**(串行化)**</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h3 id="_4-锁" tabindex="-1"><a class="header-anchor" href="#_4-锁"><span>4. 锁</span></a></h3><ul><li>属性分类：共享锁、排他锁。</li><li>粒度分类：表锁(INNODB、MYISAM)、行锁(INNODB)、页级锁(BDB引擎)、记录锁、间隙锁、临键锁。</li><li>状态分类：意向共享锁、意向排它锁。</li></ul><ol><li><strong>共享锁(Share Lock)：</strong></li></ol><p>共享锁又称读锁，简称s锁;当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</p><ol><li><strong>排他锁(Exclusive Lock)：</strong></li></ol><p>排他锁又称写锁，简称X锁:当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题</p><ol><li><strong>表锁：</strong></li></ol><p>表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问;</p><ol><li><strong>行锁：</strong></li></ol><p>行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问;</p><p>特点:粒度小，加锁麻烦，不容易冲突，相比表锁支持的并发高;</p><ol><li><strong>页锁：</strong></li></ol><p>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。</p><p>所以取了折中的页级，一次锁定相邻的一组记录。</p><p>特点:开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般</p><ol><li><strong>记录锁(Record Lock)：</strong></li></ol><p>记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。</p><p>精准条件命中，并且命中的条件字段是唯一索引</p><p>加了记录锁之后数据可以避免数据在査询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。</p><ol><li><strong>间隙锁(Gap Lock)：</strong></li></ol><p>属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。</p><p>范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现REPEATABLE_READ(可重复读)的事务级别中。</p><p>触发条件:防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。</p><p>比如表里面的数据ID 为 1,4,5,7,10,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间(-n代表负无穷大，n代表正无穷大)</p><ol><li><strong>临建锁(Next-Key Lock)：</strong></li></ol><p>也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住触发条件:范围查询并命中，查询命中了索引。结合记录锁和间隙锁的特性，临键锁避免了在范围査询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。</p><ol><li><strong>意向锁：</strong></li></ol><p>如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是意向锁。</p><ol><li><strong>意向共享锁：</strong></li></ol><p>当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁，</p><ol><li><strong>意向排他锁：</strong></li></ol><p>当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁。</p><h3 id="_5-mvcc" tabindex="-1"><a class="header-anchor" href="#_5-mvcc"><span>5. MVCC</span></a></h3><p>读取数据时通过一种类似快照的方式将数据保存下来，这样读锁和写锁就不冲突了，</p><p>不同的事务session会看到自己特定版本的数据，版本链MVCC只在读已提交和可重复读两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为读未提交总是读取最新的数据行, 而不是符合当前事务版本的数据行。而串行化则会对所有读取的行都加锁。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324600.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>聚簇索引记录中有两个必要的隐藏列：</strong></p><p>trx_id：用来存储每次对某条聚簇索引记录进行修改的时候的事务id。</p><p>roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p><p><strong>读已提交和可重复读的区别<strong><strong>就在于它们生成</strong></strong>ReadView的策略不同</strong>**：**</p><p>开始事务时创建readview，readView维护当前活动的事务id，即未提交的事务id，排序生成一个数组访问数据，获取数据中的事务id（获取的是事务id最大的记录）。</p><p>对比readview：如果在readview的左边（比readview都小），可以访问（在左边意味着该事务已经提交）如果在readview的右边（比readview都大）或者就在readview中，不可以访问，获取roll_pointer，取上一版本重新对比（在右边意味着，该事务在readview生成之后出现，在readview中意味着该事务还未提交）。</p><p>读已提交隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,</p><p>可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。</p><p>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。</p><h3 id="_6-索引" tabindex="-1"><a class="header-anchor" href="#_6-索引"><span>6. 索引</span></a></h3><p><strong>底层原理：</strong></p><p>MySQL 索引底层原理使用了B+树数据结构，它是一种平衡树，能快速定位和检索数据；B+树的叶子节点存储实际数据，中间节点存储索引，通过减少磁盘 IO 来提高查询效率；索引按照值的大小顺序排列，使得范围查询效率更高。</p><p><strong>索引类型：</strong></p><p>按照底层存储方式角度划分：</p><ul><li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li><li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MyISAM 中，不管主键还是非主键，使用的都是非聚簇索引。</li></ul><p>按照应用维度划分：</p><ul><li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li>普通索引：仅加速查询。</li><li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li><li>覆盖索引：一个索引包含（覆盖）所有需要查询的字段的值。</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><h3 id="_7-三大日志" tabindex="-1"><a class="header-anchor" href="#_7-三大日志"><span>7. 三大日志</span></a></h3><p>MySQL 日志 主要包括二进制日志、事务日志、错误日志、查询日志、慢查询日志几大类。其中，比较重要的还要属二进制日志： binlog（归档日志），事务日志：redo log（重做日志）和 undo log（回滚日志）。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324601.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>binlog：</strong><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324602.png" alt="img" loading="lazy"></p><p>binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p><p>不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。</p><p>MySQL 数据库的<strong>数据备份、主备、主主、主从</strong>都离不开 binlog，需要依靠 binlog 来同步数据，保证数据一致性。</p><p>binlog 会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p><p><strong>redo log：</strong><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324603.png" alt="img" loading="lazy"></p><p>redo log（重做日志）是 InnoDB 存储引擎独有的物理日志，让 MySQL 拥有了崩溃恢复能力。</p><p>比如 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324604.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>MySQL 中数据是以页为单位，你查询一条记录，会从硬盘中把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。</li><li>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</li><li>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里</li><li>接着清空 redolog buffer， 刷盘到 redo log 文件里。</li></ol><p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p><p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p><p><strong>undo log：</strong></p><p>每一个事务对数据的修改都会被记录到 undo log，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL可以利用 undo log 将数据恢复到事务开始之前的状态。</p><p>undo log属于逻辑日志，记录的是 SOL语句，比如说事务执行一条 DELETE 语句，那 undo log 就会记录条相对应的 INSERT 语句。同时，undo log的信息也会被记录到 redo log 中，因为 undo log也要实现持久性保护。并且，undo log本身是会被删除清理的，例如 INSERT操作，在事务提交之后就可以清除掉了;UPDATE/DELETE 操作在事务提交不会立即删除，会加入 history list，由后台线程 purge 进行清理。</p><p>undo log 是采用 segment(段)的方式来记录的，每个 undo 操作在记录的时候占用一个 undo log segment(undo日志段)，umdo log segment包含在roll back segment(回滚段)中。事务开始时，需要为其分配一个roll back segment。每个roll back segment有1024个undo log segment，这有助于管理多个并发事务的回滚需求。</p><p>通常情况下，rollback segment header(回滚段的第一个页)负责管理 rollback segment。rolback segment header 是 rollback segment 的一部分，通常在回滚段的第一个页。history list 是rollback segment header 的一部分，它的主要作用是记录所有已经提交但还没有被清理(purge)的事务的undo log。这个列表使得 purge 线程能够找到并清理那些不再需要的 undo log记录。</p><p>另外，MVCC 的实现依赖于：隐藏字段、ReadView、undolog。在内部实现中，ImnnoDB通过数据行的DB TRX ID 和 Read view 来判断数据的可见性，如不可见，则通过数据行的 DB ROLL PTR 找到 undo log中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建Read view 之前已经提交的修改和该事务本身做的修改</p><h3 id="_8-存储引擎" tabindex="-1"><a class="header-anchor" href="#_8-存储引擎"><span>8. 存储引擎</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324605.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>InnoDB（MySQL 的默认存储引擎），支持事务处理、行级锁和外键；</p><p>MyISAM 不支持事务、只有表级锁，并且不支持外键。</p><h3 id="_9-优化方案" tabindex="-1"><a class="header-anchor" href="#_9-优化方案"><span>9. 优化方案</span></a></h3><p><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96" target="_blank" rel="noopener noreferrer">MySQL常见面试题总结 | JavaGuide</a></p><ul><li>服务器优化（增加 CPU、内存、网络、更换高性能磁盘）</li><li>表设计优化（字段长度控制、添加必要的索引）</li><li>SQL 优化（避免 SQL 命中不到索引的情况）</li><li>架构部署优化（一主多从集群部署）</li><li>分库分表（垂直分库、水平分表）</li><li>读写分离</li></ul><h2 id="六、redis" tabindex="-1"><a class="header-anchor" href="#六、redis"><span>六、Redis</span></a></h2><h3 id="_1-什么是-redis" tabindex="-1"><a class="header-anchor" href="#_1-什么是-redis"><span>1. 什么是 Redis</span></a></h3><p><a href="https://redis.io/" target="_blank" rel="noopener noreferrer">Redis</a> （<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><h3 id="_2-redis-优点" tabindex="-1"><a class="header-anchor" href="#_2-redis-优点"><span>2. Redis 优点</span></a></h3><p>Redis 之所以快是因为它采用了内存存储和非阻塞的 I/O 模型，避免了磁盘 IO 的延迟；</p><p>Redis 使用了IO 多路复用技术，通过一个线程同时处理多个客户端请求，减少了线程切换的开销，提高了并发处理能力。</p><p>Redis速度快主要有以下原因：</p><p>- 基于内存存储：数据存于内存，内存读写速度远快于磁盘，避免了磁盘I/O的延迟，极大减少了数据访问时间。</p><p>- I/O多路复用技术：采用单线程（主要是网络I/O和键值对读写）结合I/O多路复用，一个线程可以同时处理多个客户端请求。就像交通警察管理交通一样，多路复用器可以同时监听多个客户端连接事件，只有当事件发生时才进行操作，避免了为每个客户端创建线程所带来的大量线程切换开销，有效提高并发处理能力。</p><p>- 高效的数据结构：Redis拥有多种简单高效的数据结构，如哈希表（查找元素平均时间复杂度为O(1)）、跳表等，这些数据结构的时间复杂度较低，能快速地操作数据。</p><h3 id="_3-redis-应用场景" tabindex="-1"><a class="header-anchor" href="#_3-redis-应用场景"><span>3. Redis 应用场景</span></a></h3><ul><li>缓存</li><li>排行榜</li><li>分布式计数器</li><li>分布式锁</li><li>消息队列</li><li>分布式token</li><li>限流</li></ul><h3 id="_4-redis-数据类型" tabindex="-1"><a class="header-anchor" href="#_4-redis-数据类型"><span>4. Redis 数据类型</span></a></h3><p><a href="https://javaguide.cn/database/redis/redis-data-structures-01.html" target="_blank" rel="noopener noreferrer">Redis 5 种基本数据类型详解 | JavaGuide</a> | <a href="https://javaguide.cn/database/redis/redis-data-structures-02.html" target="_blank" rel="noopener noreferrer">Redis 3 种特殊数据类型详解 | JavaGuide</a></p><p><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324606.png" alt="img" loading="lazy"><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324607.jpeg" alt="img" loading="lazy"></p><p>5 种基础数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p><p>3 种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。</p><p>其他的比如： Bloom filter（布隆过滤器）、Bitfield（位域）。</p><table><thead><tr><th>数据类型</th><th>使用场景</th></tr></thead><tbody><tr><td>String</td><td><strong>需要存储常规数据的场景</strong>举例：缓存 Session、Token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。相关命令：<code>SET</code>、<code>GET</code>。<strong>需要计数的场景</strong>举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。相关命令：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。<strong>分布式锁</strong>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</td></tr><tr><td>List</td><td><strong>信息流展示****举例：最新文章、最新动态。****相关命令：</strong><code>**LPUSH**</code><strong>、</strong><code>**LRANGE**</code>**。**<strong>消息队列</strong><code>**List**</code> **可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。**<strong>相对来说，Redis 5.0 新增加的一个数据结构</strong> <code>**Stream**</code> <strong>更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</strong></td></tr></tbody></table><h3 id="_5-redis-持久化机制" tabindex="-1"><a class="header-anchor" href="#_5-redis-持久化机制"><span>5. Redis 持久化机制</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324608.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>RDB（Redis Database Backup）：</strong></p><p>RDB 是 Redis 的一种快照方式的持久化方法。它定期将 Redis 内存中的数据保存到磁盘上的一个二进制文件。当 Redis 重新启动时，可以加载这个 RDB 文件来恢复之前保存的数据状态。</p><p>Redis 可以通过创建快照来获得存储在内存里面的数据在<strong>某个时间点</strong>上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><div class="language-plsql line-numbers-mode" data-highlighter="shiki" data-ext="plsql" data-title="plsql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">save </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">900</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">save </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">300</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">save </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">60</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>AOF（Append Only File）：</strong></p><p>AOF 是一种追加日志方式的持久化方法。它记录每次写操作（如 SET、INCR 等）到一个日志文件中。当 Redis 重新启动时，会重新执行这些写操作来恢复数据集的原始状态。</p><p>与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 <code>appendonly</code> 参数开启：</p><div class="language-plsql line-numbers-mode" data-highlighter="shiki" data-ext="plsql" data-title="plsql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">appendonly yes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_6-redis-的缓存穿透、缓存击穿、缓存雪崩-缓存三兄弟" tabindex="-1"><a class="header-anchor" href="#_6-redis-的缓存穿透、缓存击穿、缓存雪崩-缓存三兄弟"><span>6. Redis 的缓存穿透、缓存击穿、缓存雪崩（缓存三兄弟）</span></a></h3><p><strong>缓存穿透</strong>：缓存、数据库中都没有所查询的数据。</p><p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p><p>解决：可以通过使用布隆过滤器来快速判断请求的 Key 是否合法，避免查询不存在的数据。</p><p><strong>缓存击穿</strong>：请求的 key 对应的是热点数据，该数据存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期） 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p><p>解决：</p><ul><li><strong>永不过期</strong>（不推荐）：设置热点数据永不过期或者过期时间比较长。</li><li><strong>提前预热</strong>（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li><strong>加锁</strong>（看情况）：在缓存失效后，通过设置互斥锁确保只有一个请求去查询数据库并更新缓存。</li></ul><p><strong>缓存雪崩</strong>：缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p><p>举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p><p>解决：</p><ul><li>设置随机失效时间（可选）：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。</li><li>提前预热（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>持久缓存策略（看情况）：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。</li></ul><h3 id="_7-redis-的哨兵集群-redis-sentinel" tabindex="-1"><a class="header-anchor" href="#_7-redis-的哨兵集群-redis-sentinel"><span>7. Redis 的哨兵集群（Redis Sentinel）</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324609.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Redis 的哨兵集群主要用于实现高可用性，监控主、从节点的状态变化，并在主节点失效时自动将从节点升级为主节点。</p><p>哨兵集群由多个哨兵节点组成，工作原理是哨兵节点通过相互通信，监测主节点的健康状态。</p><p>当主节点失效时，选举新的主节点，并通知其他从节点进行切换，确保系统的可用性。</p><h3 id="_8-redis-的分片集群-redis-cluster" tabindex="-1"><a class="header-anchor" href="#_8-redis-的分片集群-redis-cluster"><span>8. Redis 的分片集群（Redis Cluster）</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324610.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>多个主从节点 一致性哈希算法</p><p>Redis 的分片集群主要用于实现数据的横向扩展，将数据分散存储在多个节点上，</p><p>提高系统的并发能力和存储能力。分片集群由多个主从节点组成，根据 Key 经过哈希算</p><p>法映射到不同的节点上，每个节点负责存储和处理一部分数据，工作原理是通过一</p><p>致性哈希算法将数据按照一定规则分配到不同的节点上，实现数据的均衡存储和查</p><p>询。</p><h3 id="_9-redis-或-elasticsearch-和-mysql-如何保持数据一致性" tabindex="-1"><a class="header-anchor" href="#_9-redis-或-elasticsearch-和-mysql-如何保持数据一致性"><span>9. Redis（或 ElasticSearch）和 MySQL 如何保持数据一致性</span></a></h3><ul><li>双写 | 异步队列 | Canal 方案</li></ul><ol><li>双写：每次写入操作同时将数据写入 Elasticsearch 和 MySQL，确保数据一致性，但可能增加写延迟和复杂性。</li><li>异步队列：将写入操作请求放入队列中，后台任务异步地将数据写入Elasticsearch 和 MySQL，提高写入性能，但可能导致一定的数据不一致性。</li><li>Canal 方案：使用 Canal 工具订阅 MySQL 的 binlog 日志，实时将数据同步到 Elasticsearch，实现数据的实时增量同步，但需要额外的工具和配置。</li></ol><h3 id="_10-redis-分布式锁" tabindex="-1"><a class="header-anchor" href="#_10-redis-分布式锁"><span>10. <a href="https://javaguide.cn/distributed-system/distributed-lock.html" target="_blank" rel="noopener noreferrer">Redis 分布式锁</a></span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324611.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324612.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>分布式锁的用途：分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。</li><li>分布式锁的应该具备的条件：互斥、高可用、可重入、高性能、非阻塞。</li><li>分布式锁的常见实现方式：关系型数据库比如 MySQL、分布式协调服务 ZooKeeper、分布式键值存储系统比如 Redis 、Etcd 。</li></ul><h3 id="_11-redisson-是什么-怎么用" tabindex="-1"><a class="header-anchor" href="#_11-redisson-是什么-怎么用"><span>11. Redisson 是什么，怎么用</span></a></h3><ul><li>redis 客户端 api 依赖 配置 注解/对象</li></ul><p>最简回答：Redisson 是一个 Java 的 Redis 客户端，提供丰富的 API 和功能，用于</p><p>封装分布式操作和并发控制。在 Spring Boot 中使用 Redisson，首先添加 Redisson</p><p>的依赖，然后在配置文件中配置 Redisson 连接信息，接着通过@Autowired 注解</p><p>或手动创建 RedissonClient 对象。最后，利用 RedissonClient 对象可以使用各种</p><p>功能，如分布式锁、分布式集合等，与 Redis 进行交互。</p><h3 id="_12-redisson-看门狗机制的原理" tabindex="-1"><a class="header-anchor" href="#_12-redisson-看门狗机制的原理"><span>12. Redisson 看门狗机制的原理</span></a></h3><ul><li>定时续期锁的过期时间</li></ul><p>最简回答：Redisson 的看门狗机制通过定时续期锁的过期时间，保证在业务执行期</p><p>间锁不会被自动释放。它解决了分布式环境下锁过期导致的资源竞争问题，确保业</p><p>务能够完成。续期是看门狗机制的核心，它通过定时更新锁的过期时间来实现锁的</p><p>持久性，以防止锁过期并被其他实例获得。</p><h3 id="_13-redis-bigkey-大key" tabindex="-1"><a class="header-anchor" href="#_13-redis-bigkey-大key"><span>13. Redis bigkey（大key）</span></a></h3><ul><li>大量 key 同时过期 | 随机过期 lazy free</li></ul><p>什么是 bigkey？</p><p>当 Redis 中存在大量 key 在同一时间点集中过期时，可能会导致以下问题：</p><ul><li><strong>请求延迟增加：</strong> Redis 在处理过期 key 时需要消耗 CPU 资源，如果过期 key 数量庞大，会导致 Redis 实例的 CPU 占用率升高，进而影响其他请求的处理速度，造成延迟增加。</li><li><strong>内存占用过高：</strong> 过期的 key 虽然已经失效，但在 Redis 真正删除它们之前，仍然会占用内存空间。如果过期 key 没有及时清理，可能会导致内存占用过高，甚至引发内存溢出。</li></ul><p>如何解决 bigkey？</p><ol><li><strong>尽量避免 key 集中过期</strong>： 在设置键的过期时间时尽量随机一点。</li><li><strong>开启 lazy free 机制</strong>：修改 <code>redis.conf</code> 配置文件，将 <code>lazyfree-lazy-expire</code> 参数设置为 <code>yes</code>，即可开启 lazy free 机制。开启 lazy free 机制后，Redis 会在后台异步删除过期的 key，不会阻塞主线程的运行，从而降低对 Redis 性能的影响。</li></ol><h3 id="_14-redis-hotkey-热key" tabindex="-1"><a class="header-anchor" href="#_14-redis-hotkey-热key"><span>14. Redis hotkey（热Key）</span></a></h3><ul><li>key 的访问次数多 | 主从读写分离 集群 二级缓存</li></ul><p>什么是 hotkey？</p><p>如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 <strong>hotkey（热 Key）</strong>。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。</p><p>hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p><p>如何解决 hotkey？</p><p>hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p><ul><li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</li><li><strong>Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</li><li><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</li></ul><h2 id="七、微服务" tabindex="-1"><a class="header-anchor" href="#七、微服务"><span>七、微服务</span></a></h2><h3 id="_1-spring" tabindex="-1"><a class="header-anchor" href="#_1-spring"><span>1. Spring</span></a></h3><p>Spring 是一款开源的轻量级 JavaEE 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p><h3 id="_2-spring-ioc" tabindex="-1"><a class="header-anchor" href="#_2-spring-ioc"><span>2. Spring IOC</span></a></h3><ul><li>控制反转 | 容器控制对象的创建和依赖关系</li></ul><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324613.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>IOC (Inversion of Control，控制反转) 是一种设计思想，通过它，容器控制对象的创建和依赖关系，从而实现对象之间的解耦和灵活性的提升。 在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><h3 id="_3-spring-aop" tabindex="-1"><a class="header-anchor" href="#_3-spring-aop"><span>3. Spring AOP</span></a></h3><ul><li>面向切面编程 | 动态代理： JDK 实现接口 CGLIB 没有实现接口 | AOP 术语</li></ul><p>AOP(Aspect-Oriented Programming，面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>AOP的底层机制是动态代理，实现方式有两种：JDK动态代理和CGLIB动态代理</p><p>如果想要代理的目标对象实现了接口，使用JDK动态代理（Spring在运行时创建了一个实现了目标</p><p>对象所有接口的新对象）。</p><p>如果想要代理的目标对象没有实现接口，使用CGLIB动态代理（Spring在运行时使用CGLIB库生成</p><p>目标类的子类对象）。</p><table><thead><tr><th>AOP 术语</th><th>含义</th></tr></thead><tbody><tr><td>目标(Target)</td><td>被通知的对象</td></tr><tr><td>代理(Proxy)</td><td>向目标对象应用通知之后创建的代理对象</td></tr><tr><td>连接点(JoinPoint)</td><td>目标对象的所属类中，定义的所有方法均为连接点</td></tr><tr><td>切入点(Pointcut)</td><td>被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr><tr><td>通知(Advice)</td><td>增强的逻辑 / 代码，即拦截到目标对象的连接点之后要做的事情</td></tr><tr><td>切面(Aspect)</td><td>切入点(Pointcut)+通知(Advice)</td></tr><tr><td>Weaving(织入)</td><td>将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Aspect</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserServiceAspect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Pointcut</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;execution(* com.example.aop.service.UserServiceImpl.*(..))&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> pointcut</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Before</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;pointcut()&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> before</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">JoinPoint</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> joinPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> methodName</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> joinPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSignature</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;开始执行&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> methodName </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;方法&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">AfterReturning</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">pointcut</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;pointcut()&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> returning</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;result&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> afterReturning</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">JoinPoint</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> joinPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> result</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;方法返回结果：&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> result);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">After</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;pointcut()&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> after</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">JoinPoint</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> joinPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> methodName</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> joinPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSignature</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(methodName </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;方法执行完毕&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Around</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;pointcut()&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> around</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ProceedingJoinPoint</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> joinPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Throwable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> methodName</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> joinPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSignature</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;开始执行&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> methodName </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;方法&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Object</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> result</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> joinPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">proceed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;方法返回结果：&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> result);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(methodName </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;方法执行完毕&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> result;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**切点表达式（Pointcut Expression）：**用于描述哪些方法执行时应该被增强。</p><p>execution(* com.example.aop.service.UserServiceImpl.*(..))</p><ul><li><code>*</code>，表示匹配任意返回类型的方法</li><li><code>com.example.aop.service.UserServiceImpl</code> ，表示匹配UserServiceImpl类里的方法</li><li><code>*</code>，表示匹配类里的所有方法</li><li><code>(..)</code>，表示匹配任意输入参数的方法</li></ul><p>**通知(Advice)：**增强的逻辑 / 代码</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324614.jpeg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>前置通知（@Before）：在目标方法执行之前执行。 Before）：在目标方法执行之前执行。</li><li>后置通知（@After）：在目标方法执行之后执行。</li><li>返回后通知（@AfterReturning）：在目标方法正常返回后执行，可以获取方法返回值等信息。</li><li>环绕通知（@Around）：在目标方法执行前后执行自定义逻辑。</li><li>异常通知（@AfterThrowing）：在目标方法抛出异常后执行，可以获取异常信息。</li></ul><h3 id="_4-声明成-bean-注解的方式" tabindex="-1"><a class="header-anchor" href="#_4-声明成-bean-注解的方式"><span>4. 声明成 Bean 注解的方式</span></a></h3><ul><li><p>注解分层讨论</p></li><li><p><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</p></li><li><p><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p></li><li><p><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p></li><li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</p></li><li><p><code>@Configuration</code> 和 <code>@Bean</code> 组合使用 : <code>@Configuration</code> 标记一个类为配置类，然后在该类中使用 <code>@Bean</code> 方法来定义 Bean。</p></li></ul><h3 id="_5-component-和-bean-区别" tabindex="-1"><a class="header-anchor" href="#_5-component-和-bean-区别"><span>5. @Component 和 @Bean 区别</span></a></h3><ul><li><p><code>@Component</code> 作用于类 |<code>@Bean</code> 作用于方法，自定义性更强，三方库中的类</p></li><li><p><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</p></li><li><p><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。|<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p></li><li><p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</p></li></ul><h3 id="_6-autowired-和-resource-的区别" tabindex="-1"><a class="header-anchor" href="#_6-autowired-和-resource-的区别"><span>6. @Autowired 和 @Resource 的区别</span></a></h3><ul><li><p><code>**@Autowired**</code> <strong>Spring 注解 by 类型 作用范围大 |</strong><code>**@Resource**</code> <strong>JDK 注解 by 名称</strong></p></li><li><p><code>**@Autowired**</code> <strong>是</strong> <strong>Spring</strong> <strong>提供的注解，</strong><code>**@Resource**</code> <strong>是</strong> <strong>JDK</strong> <strong>提供的注解。</strong></p></li><li><p><code>**Autowired**</code> <strong>默认的注入方式为</strong><code>**byType**</code><strong>（根据<strong><strong>类型</strong></strong>进行匹配），</strong><code>**@Resource**</code><strong>默认注入方式为</strong> <code>**byName**</code><strong>（根据<strong><strong>名称</strong></strong>进行匹配）。</strong></p></li><li><p><strong>当一个接口存在<strong><strong>多个实现类</strong></strong>的情况下，</strong><code>**@Autowired**</code> <strong>和</strong><code>**@Resource**</code><strong>都需要通过<strong><strong>名称</strong></strong>才能正确匹配到对应的 Bean。</strong><code>**Autowired**</code> <strong>可以通过</strong> <code>**@Qualifier**</code> <strong>注解来显式指定名称，</strong><code>**@Resource**</code><strong>可以通过</strong> <code>**name**</code> <strong>属性****来显式指定名称。</strong></p></li><li><p><code>**@Autowired**</code> <strong>支持在<strong><strong>构造函数、参数、方法、字段</strong></strong>上使用。</strong><code>**@Resource**</code> <strong>主要用于<strong><strong>字段和方法</strong></strong>上的注入，不支持在<strong><strong>构造函数或参数</strong></strong>上使用。</strong></p></li></ul><h3 id="_7-注入-bean-的方式" tabindex="-1"><a class="header-anchor" href="#_7-注入-bean-的方式"><span>7. 注入 Bean 的方式</span></a></h3><ul><li>构造函数 setter 注解</li></ul><p>依赖注入 (Dependency Injection, DI) 的常见方式：</p><ol><li>构造函数注入：通过类的构造函数来注入依赖项。</li><li>Setter 注入：通过类的 Setter 方法来注入依赖项。</li><li>Field（字段） 注入：直接在类的字段上使用注解（如 <code>@Autowired</code> 或 <code>@Resource</code>）来注入依赖项。</li></ol><h3 id="_8-spring-mvc-原理" tabindex="-1"><a class="header-anchor" href="#_8-spring-mvc-原理"><span>8. Spring MVC 原理</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324615.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>• DispatcherServlet：前端控制器，负责接收请求、分发，并给予客户端响应。 • HandlerMapping：处理器映射器，根据 URL 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。 • HandlerAdapter：处理器适配器，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler。 • Handler：请求处理器，处理实际请求的处理器。 • ViewResolver：视图解析器，根据 Handler 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端。</p><ol><li>客户端（浏览器）发送请求， DispatcherServlet 前端控制器 拦截请求。</li><li>DispatcherServlet 根据请求信息调用 HandlerMapping 处理器映射器。</li><li>HandlerMapping 根据 URL 去匹配查找能处理的 Handler 处理器（Controller 控制器） ，并会将请求涉及到的拦截器和 Handler一起封装。</li><li>DispatcherServlet 调用 HandlerAdapter 处理器适配器。</li><li>HandlerAdapter 请求执行 Handler。</li><li>Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象 给 HandlerAdapter，ModelAndView 顾名思义，包含了数据模型以及相应的视图信息。Model 是返回的数据对象，View是个逻辑上的 View。</li><li>HandlerAdapter 会返回 ModelAndView 对象给 DispatcherServlet。</li><li>HandlerAdapter 请求 ViewResolver 视图解析器，根据逻辑 View 查找实际的 View。</li><li>ViewResolver 返回 View 对象给 DispatcherServlet。</li><li>DispaterServlet 把返回的 Model 传给 View（渲染视图）。</li><li>View 被返回给 请求者（浏览器）。</li></ol><h3 id="_9-springboot-优点" tabindex="-1"><a class="header-anchor" href="#_9-springboot-优点"><span>9. SpringBoot 优点</span></a></h3><ul><li><p>内嵌服务器 简化配置 自动配置 监控管理</p></li><li><p>独立运行 Spring Boot ，内嵌了 servlet 容器，如 Tomcat、Jetty 等，现在不再需要打成 war 包部署到容器中，Spring Boot 只要打成一个可执行的 jar 包就能独立运行，所有的依赖包都在一个 jar 包内。</p></li><li><p>简化配置 spring-boot-starter-web 启动器自动依赖其他组件，简少了maven 的配置。</p></li><li><p>自动配置 Spring Boot 能根据当前类路径下的类、jar 包来自动配置 bean，如添加一个 spring-boot-starter-web 启动器就能拥有 web 的功能，无需其他配置。</p></li><li><p>无代码生成和 XML 配置， Spring Boot 配置过程中无代码生成，也无需 XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x 的核心功能之一。</p></li><li><p>避免大量的 Maven 导入和各种版本冲突</p></li><li><p>应用监控 Spring Boot 提供一系列端点可以监控服务及应用，做健康检测。</p></li></ul><h3 id="_10-springboot-自动配置原理" tabindex="-1"><a class="header-anchor" href="#_10-springboot-自动配置原理"><span>10. <a href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html" target="_blank" rel="noopener noreferrer">SpringBoot 自动配置原理</a></span></a></h3><p>Spring Boot 通过@EnableAutoConfiguration开启自动装配，通过 SpringFactoriesLoader 最终加载META-INF/spring.factories中的自动配置类实现自动装配，自动配置类其实就是通过@Conditional按需加载的配置类，想要其生效必须引入spring-boot-starter-xxx包实现起步依赖</p><p><strong>1. 启动类与注解：</strong></p><ul><li><p>Spring Boot应用通常以一个带有 <code>@SpringBootApplication</code> 注解的主启动类开始。这个注解实际上是一个组合注解，它包含了以下几个重要注解：</p></li><li><ul><li><code>@Configuration</code>：表明该类是一个配置类，用于定义各种Bean以及配置信息，相当于传统Spring项目中的XML配置文件的作用。</li><li><code>@EnableAutoConfiguration</code>：这是实现自动配置的关键注解。它会触发Spring Boot去查找并应用所有符合条件的自动配置类。</li><li><code>@ComponentScan</code>：用于扫描指定包及其子包下的所有带有 <code>@Component</code> 注解（以及其衍生注解，如 <code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等）的类，将它们作为Spring容器中的组件进行管理。</li></ul></li></ul><p><strong>2. 自动配置类查找：</strong></p><ul><li>当应用启动时，在 <code>@EnableAutoConfiguration</code> 注解的作用下，Spring Boot会去查找所有的自动配置类。这些自动配置类通常位于 <code>spring-boot-autoconfigure</code> 项目的 <code>META-INF/spring-boot-autoconfigure.properties</code> 文件中定义的包路径下，例如 <code>org.springframework.boot.autoconfigure</code> 及其子包。</li><li>自动配置类的命名规范一般是 <code>XXXAutoConfigure</code>，比如 <code>DataSourceAutoConfigure</code> 用于自动配置数据源。</li></ul><p><strong>3. 条件注解判断：</strong></p><ul><li><p>每个自动配置类上通常会带有一些条件注解（Conditional Annotation），这些条件注解用于判断当前项目的实际情况是否满足该自动配置类生效的条件。常见的条件注解有：</p></li><li><ul><li><code>@ConditionalOnClass</code>：当项目中存在指定的类时，该自动配置类才生效。例如，对于 <code>DataSourceAutoConfigure</code> 配置类，可能会有 <code>@ConditionalOnClass({DataSource.class})</code> 注解，这意味着只有当项目中引入了 <code>DataSource</code> 类（通常是引入了数据库驱动依赖后才会有这个类）时，该自动配置类才会对数据源进行自动配置。</li><li><code>@ConditionalOnMissingClass</code>：与 <code>@ConditionalOnClass</code> 相反，当项目中不存在指定的类时，该自动配置类才生效。</li><li><code>@ConditionalOnProperty</code>：根据项目中配置属性的值来判断自动配置类是否生效。比如，如果配置属性 <code>spring.datasource.url</code> 有特定的值，那么相关的数据源自动配置类可能会根据这个值来进一步调整配置。</li><li><code>@ConditionalOnBean</code>：当Spring容器中已经存在指定的Bean时，该自动配置类才生效。</li><li><code>@ConditionalOnMissingBean</code>：当Spring容器中不存在指定的Bean时，该自动配置类才生效。</li></ul></li></ul><p><strong>4. 自动配置逻辑执行：</strong></p><ul><li><p>当一个自动配置类通过条件注解判断满足生效条件后，它就会执行内部的配置逻辑。这通常包括以下几个方面：</p></li><li><ul><li>**定义Bean：**自动配置类会在Spring容器中定义各种所需的Bean。例如，在 <code>DataSourceAutoConfigure</code> 中，会定义数据源相关的Bean，如 <code>DataSource</code> 本身、连接池相关的Bean等。</li><li><strong>设置属性</strong>：会根据项目中现有的配置信息（如配置文件中的属性值、环境变量等）来设置这些Bean的属性。比如，根据 <code>spring.datasource.url</code>、<code>spring.datasource.username</code>、<code>spring.datasource.password</code> 等属性值来设置数据源Bean的连接参数。</li><li><strong>依赖注入</strong>：将定义好的Bean进行相互之间的依赖注入，使得它们能够协同工作。例如，将数据源Bean注入到需要使用数据源的其他组件（如数据访问层的 <code>Repository</code> 类）中。</li></ul></li></ul><p><strong>5. 自定义配置覆盖：</strong></p><ul><li>虽然Spring Boot有强大的自动配置功能，但开发人员仍然可以根据项目的特殊需求对自动配置进行定制。</li><li>如果开发人员在项目中添加了自定义的配置类或者在配置文件中设置了与自动配置相关的属性值，那么这些自定义的配置会覆盖自动配置类中的相应部分。例如，如果开发人员在配置文件中明确设置了 <code>spring.datasource.url</code> 的值，那么自动配置类就会按照这个值来配置数据源，而不是按照默认的推断方式。</li></ul><h3 id="_11-springboot-启动事项" tabindex="-1"><a class="header-anchor" href="#_11-springboot-启动事项"><span>11. SpringBoot 启动事项</span></a></h3><ol><li>加载配置：Spring Boot 启动时首先加载<code>META-INF/spring.factories</code>文件，这个 文件指定了各个自动配置类的路径。</li><li>扫描自动配置类：根据<code>spring.factories</code>中配置的自动配置类路径，Spring Boot 会扫描这些自动配置类，并将它们实例化。</li><li>条件判断：通过条件注解，如<code>@ConditionalOnClass</code>、<code>@ConditionalOnProperty</code> 等，决定是否应用该自动配置类。</li><li>自动配置：根据自动配置类中的代码逻辑，自动配置相应的组件，例如：数据库连接池、Web 服务器、日志等。</li><li>注册组件：将自动配置的组件注册到 Spring 容器中，使其可以被应用程序使用。</li><li>启动应用：执行应用程序的启动逻辑，包括：初始化、加载数据、启动定时任务等。</li></ol><h3 id="_12-spring-security" tabindex="-1"><a class="header-anchor" href="#_12-spring-security"><span>12. Spring Security</span></a></h3><p>控制请求权限的方法：</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324616.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><code>permitAll()</code>：无条件允许任何形式访问，不管你登录还是没有登录。</li><li><code>anonymous()</code>：允许匿名访问，也就是没有登录才可以访问。</li><li><code>denyAll()</code>：无条件拒绝任何形式的访问。</li><li><code>authenticated()</code>：只允许已认证的用户访问。</li><li><code>fullyAuthenticated()</code>：只允许已经登录或者通过 remember-me 登录的用户访问。</li><li><code>hasRole(String)</code> : 只允许指定的角色访问。</li><li><code>hasAnyRole(String)</code> : 指定一个或者多个角色，满足其一的用户即可访问。</li><li><code>hasAuthority(String)</code>：只允许具有指定权限的用户访问。</li><li><code>hasAnyAuthority(String)</code>：指定一个或者多个权限，满足其一的用户即可访问。</li><li><code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li></ul><h3 id="_13-mybatis-和-区别" tabindex="-1"><a class="header-anchor" href="#_13-mybatis-和-区别"><span>13. MyBatis #{} 和 \${} 区别</span></a></h3><p># 用于参数的替换，并会进行预编译处理，以防止 SQL 注入。</p><p>$ 将变量直接替换进 SQL 语句，有 SQL 注入风险。</p><h3 id="_14-mybatis-动态-sql" tabindex="-1"><a class="header-anchor" href="#_14-mybatis-动态-sql"><span>14. MyBatis 动态 SQL</span></a></h3><p>MyBatis 动态 sql 可以让我们在 xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p><p>MyBatis 提供了 9 种动态 sql 标签:</p><ul><li><code>&lt;if&gt;&lt;/if&gt;</code></li><li><code>&lt;where&gt;&lt;/where&gt;(trim,set)</code></li><li><code>&lt;choose&gt;&lt;/choose&gt;（when, otherwise）</code></li><li><code>&lt;foreach&gt;&lt;/foreach&gt;</code></li><li><code>&lt;bind/&gt;</code></li></ul><h3 id="_15-resulttype-和-resultmap-的区别" tabindex="-1"><a class="header-anchor" href="#_15-resulttype-和-resultmap-的区别"><span>15. ResultType 和 ResultMap 的区别</span></a></h3><p>¢ 如果数据库结果集中的列名和要封装实体的属性名完全一致的话用resultType 属性</p><p>¢ 如果数据库结果集中的列名和要封装实体的属性名有不一致的情况用resultMap 属性，通过 resultMap 手动建立对象关系映射，resultMap 要配置一下表和类的一一对应关系，所以说就算你的字段名和你的实体类的属性名不一样也没关系，都会给你映射出来</p><h3 id="_16-mybatis-和-hibernate-区别" tabindex="-1"><a class="header-anchor" href="#_16-mybatis-和-hibernate-区别"><span>16. Mybatis 和 Hibernate 区别</span></a></h3><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p><p>MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p><h3 id="_17-mybatisplus-常用注解" tabindex="-1"><a class="header-anchor" href="#_17-mybatisplus-常用注解"><span>17. MyBatisPlus 常用注解</span></a></h3><ol><li>@TableName：用于指定实体类对应的数据库表名。该注解可以在实体类上添加，表示该类映射到指定的数据库表。例如：@TableName(&quot;user&quot;)。</li><li>@TableField：用于指定实体类的字段对应的数据库表的字段名。该注解可以在实体类的字段上添加，表示该字段映射到指定的数据库表字段。例如：@TableField(&quot;name&quot;)。</li><li>@TableId：用于指定实体类的字段作为数据库表的主键。该注解可以在实体类的字段上添加，表示该字段作为数据库表的主键。例如：@TableId(value = &quot;id&quot;, type= IdType.AUTO)。</li><li>@Version：用于指定实体类的字段作为乐观锁的版本字段。乐观锁是一种并发控制机制，通过版本号的变化来判断数据是否被修改。该注解可以在实体类的字段上添加，表示该字段作为乐观锁的版本字段。例如：@Version。</li></ol><h3 id="_18-springcloud-组件" tabindex="-1"><a class="header-anchor" href="#_18-springcloud-组件"><span>18. SpringCloud 组件</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324617.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324618.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>服务注册与发现（Eureka/Nacos）：Eureka 是一个用于实现服务注册与发现的组件，提 供了服务注册中心来管理服务实例的注册和发现，使得服务之间可以方便地进行通信和 调用。</li><li>客户端负载均衡（Ribbon/Nginx）：Ribbon 是一个用于在客户端实现负载均衡的组件， 它可以根据一定的策略选择合适的服务实例进行负载均衡，提高系统的可用性和性能。</li><li>服务调用（Feign）：Feign 是一个声明式的服务调用组件，它基于注解和动态代理， 可以让开发者使用简单的接口定义服务调用，而无需关注底层的具体实现。</li><li>熔断器（Hystrix/Sentinel）：Hystrix 是一个用于实现服务容错和熔断的组件，它可以保护 系统免受服务故障的影响，通过实现服务降级、熔断和隔离等机制，提高系统的稳定性 和可靠性。</li><li>网关（Gateway）：Zuul 或 Gateway 是用于构建统一 API 网关的组件，它可以 实现请求的路由、过滤和转发等功能，提供了对外的统一的接入点，并可以对请求进行 安全验证、限流和监控等。</li></ol><h3 id="_19-eureka-工作原理" tabindex="-1"><a class="header-anchor" href="#_19-eureka-工作原理"><span>19. Eureka 工作原理</span></a></h3><p>Eureka 是一个用于实现服务注册与发现的组件。</p><p>通过服务注册，在启动时将服务实例信息注册到 Eureka 注册中心；</p><p>通过心跳检测与续约，实现服务实例的健康状态监测；</p><p>通过服务发现，让消费者能够从注册中心获取可用的服务列表；</p><p>通过负载均衡和容错处理，实现服务调用的负载均衡和容错能力。</p><h3 id="_20-nacos-工作原理" tabindex="-1"><a class="header-anchor" href="#_20-nacos-工作原理"><span>20. Nacos 工作原理</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324619.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Nacos 实现了服务发现、服务配置、服务元数据及流量管理。</p><p>它提供了服务提供者将服务注册到注册中心，并让让从注册中心发现服务实例的能力。</p><p>注册中心通过两种类型的实例进行管理，包括临时实例和非临时实例。临时实例会定期发送</p><p>心跳信号以保持连接，而非临时实例则长时间提供服务。注册中心通过定期的心跳检查来监测实例的可用性，并在长时间没有心跳信号时将失效实例剔除。</p><h3 id="_21-nacos-和-eureka-的区别" tabindex="-1"><a class="header-anchor" href="#_21-nacos-和-eureka-的区别"><span>21. Nacos 和 Eureka 的区别</span></a></h3><p>Nacos 和 Eureka 都是服务注册与发现组件，但 Nacos 比 Eureka 功能更丰富，除了服务注册与发现外，还提供了服务配置和管理功能。</p><p>Nacos 支持多种服务发现协议，如 DNS、HTTP 和 gRPC，而 Eureka 仅支持自身的协议。</p><p>Nacos 还具备更好的可扩展性和容错性，能够应对更复杂的场景。</p><h3 id="_22-ribbon-工作原理" tabindex="-1"><a class="header-anchor" href="#_22-ribbon-工作原理"><span>22. Ribbon 工作原理</span></a></h3><p>Ribbon是基于 Netflix Ribbon 实现的一套客户端的负载均衡工具，Ribbon客户端组件提供一系列的完善的配置，如超时，重试等。</p><p>目前主流的负载方案分为以下两种：</p><p>• 集中式负载均衡：在消费者和服务提供方中间使用独立的代理方式进行负载，有硬件的（比如 F5），也有软件的（比如 Nginx）。</p><p>• 客户端根据自己的请求情况做负载均衡：Ribbon 就属于客户端自己做负载均衡。</p><p>常见负载均衡算法：</p><p>• 随机：通过随机选择服务进行执行，一般这种方式使用较少;</p><p>• 轮询：负载均衡默认实现方式，请求来之后排队处理;</p><p>• 加权轮询：通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个服务器的压力;</p><p>• 地址哈希（IP hash）：通过客户端请求的地址的HASH值取模映射进行服务器调度。</p><p>• 最小链接数：即使请求均衡了，压力不一定会均衡，最小连接数法就是根据服务器的连接情况，比如请求积压数等参数，将请求分配到当前压力最小的服务器上。</p><h3 id="_23-feign-工作原理" tabindex="-1"><a class="header-anchor" href="#_23-feign-工作原理"><span>23. Feign 工作原理</span></a></h3><p>Feign 是一个声明式的 Web 服务客户端，用于简化和优化服务之间的 HTTP 通信，可以做到使用 HTTP 请求远程服务时就像调用本地方法一样的体验。</p><ol><li>接口定义：开发者通过定义 Java 接口来描述服务间的通信协议，包括 URL、请求方法、请求参数等。</li><li>代理生成：在应用启动时，Feign 会根据接口定义生成代理对象。</li><li>请求发送：当调用代理对象的方法时，Feign 会根据方法的注解和参数生成 HTTP请求，并发送给目标服务。</li><li>负载均衡：Feign 集成了负载均衡组件（如 Ribbon），可以自动将请求分发到不同的服务实例。</li><li>响应处理：目标服务处理完请求后，将响应返回给 Feign 客户端。</li><li>结果解析：Feign 会根据接口定义和注解，将 HTTP 响应解析为 Java 对象，并返回给调用者。</li></ol><p>总结起来，Feign 的工作原理就是根据接口定义生成代理对象，通过代理对象发送 HTTP请求给目标服务，并将响应解析为 Java 对象返回给调用者。这样，开发者可以使用简洁的接口定义来实现服务之间的通信。</p><h3 id="_24-hystrix-工作原理" tabindex="-1"><a class="header-anchor" href="#_24-hystrix-工作原理"><span>24. Hystrix 工作原理</span></a></h3><p>Hystrix 是一个用于实现服务容错和熔断的库，在分布式系统中起到了保护系统免受服务故障的影响的作用。</p><ol><li>熔断条件：</li></ol><ul><li>Hystrix 根据一定的规则监控执行的服务请求，当错误率超过一定阈值时，触发熔断。</li><li>默认情况下，如果在 10 秒内的请求错误率超过 50%，则触发熔断。</li></ul><ol><li>熔断后的处理：</li></ol><ul><li>当熔断触发后，Hystrix 会停止请求该服务的发送，而是快速返回一个预设的fallback（降级）响应或空响应。</li><li>在熔断打开期间，Hystrix 还会定时尝试发起一些请求观察该服务是否已经恢复，如果请求成功率较高，熔断器将逐渐关闭。</li></ul><ol><li>熔断的好处：</li></ol><ul><li>减少联动效应：当一个服务发生故障或响应时间过长时，传统的做法是等待它超 时并再次尝试。这会浪费系统资源，而 Hystrix 的熔断机制可以快速失败并返回降级的 响应，减少了等待和资源浪费。</li><li>提高系统稳定性：通过熔断机制，当某个服务出现故障或不可用时，可以快速切 换到备用的降级逻辑，保护整个系统免受服务故障的影响。</li><li>预防雪崩效应：当一个服务不可用或响应缓慢时，传统的做法是继续发送请求，导致失败的请求堆积并最终耗尽系统资源。而 Hystrix 的熔断机制能够避免这种情况的发生，减少了对失败服务的依赖，提高了系统的稳定性。</li></ul><p>总而言之，Hystrix 的熔断机制通过监控服务请求的错误率，当错误率超过阈值时，快速切换到备用逻辑，避免了对失败服务的不必要请求，提高了系统的稳定性和可靠性。熔断可以在故障发生时快速失败并返回降级响应，避免资源浪费和雪崩效应，保护系统免受故障服务的影响。</p><h3 id="_25-sentinel-工作原理" tabindex="-1"><a class="header-anchor" href="#_25-sentinel-工作原理"><span>25. Sentinel 工作原理</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324620.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324621.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324622.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324623.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324624.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_26-gateway-工作原理" tabindex="-1"><a class="header-anchor" href="#_26-gateway-工作原理"><span>26. Gateway 工作原理</span></a></h3><p>Gateway（网关）是一种在微服务架构中起到请求转发、路由和过滤作用的组件。它作为系统入口，接收所有的客户端请求，并将它们转发到相应的服务上进行处理。</p><ol><li>请求路由：可以根据请求的 URL 路径将请求动态路由到不同的服务实例上，实现动态路由的功能。</li><li>负载均衡：可以根据负载均衡策略将请求分发到多个服务实例中，平衡负载，提高系统的可用性和性能。</li><li>安全控制：可以集成认证和授权机制，对请求进行鉴权，保护系统的安全性。</li><li>请求过滤：可以对请求进行过滤和校验，例如对请求进行验证、请求参数转换、请求日志记录等。</li><li>降级和熔断：可以对服务进行降级和熔断处理，当服务出现故障或超时时，返回预设的响应或转发到备用服务。</li><li>监控和统计：可以对请求进行监控和统计，记录请求的响应时间、流量等指标，方便分析系统性能和问题排查。</li></ol><h3 id="_27-skywalking-工作原理" tabindex="-1"><a class="header-anchor" href="#_27-skywalking-工作原理"><span>27. Skywalking 工作原理</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324625.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324626.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>探针：基于不同的来源可能是不一样的, 但作用都是收集数据, 将数据格式化为SkyWalking 适用的格式.</p><p>平台后端：支持数据聚合, 数据分析以及驱动数据流从探针到用户界面的流程。分析包括Skywalking 原生追踪和性能指标以及第三方来源，包括 Istio 及 Envoy telemetry , Zipkin 追踪格式化等。</p><p>存储：通过开放的插件化的接口存放 SkyWalking 数据. 你可以选择一个既有的存储系统, 如ElasticSearch, H2 或 MySQL 集群(Sharding-Sphere 管理),也可以选择自己实现一个存储系统. 当然, 我们非常欢迎你贡献新的存储系统实现。</p><p>UI：一个基于接口高度定制化的Web系统，用户可以可视化查看和管理 SkyWalking 数据</p><h2 id="八、分布式" tabindex="-1"><a class="header-anchor" href="#八、分布式"><span>八、分布式</span></a></h2><h3 id="_1-rabbitmq-工作模式" tabindex="-1"><a class="header-anchor" href="#_1-rabbitmq-工作模式"><span>1. RabbitMQ 工作模式</span></a></h3><p>RabbitMQ 是一个广泛使用的开源消息代理，它支持多种工作模式。</p><p>1**. 简单模式（Simple Mode）**</p><ul><li>**<strong>特点</strong>：**使用单个生产者将消息发送到单个消费者。</li><li>**应用场景：**适用于简单的任务分发，消息的顺序不重要。</li></ul><p><strong>2. 工作队列模式（Work Queue Mode）</strong></p><ul><li>**特点：**多个生产者将消息发送到一个或多个消费者。</li><li>**应用场景：**适用于任务分发，提高系统的并发处理能力。</li></ul><p><strong>3. 发布/订阅模式（Publish/Subscribe Mode）</strong></p><ul><li>**特点：**消息发送者将消息发布到交换机，多个消费者通过绑定到交换机的队列接收消息。</li><li>**应用场景：**适用于消息广播，例如：日志记录、实时聊天、新闻发布等。</li></ul><p><strong>4. 路由模式（Routing Mode）</strong></p><ul><li>**特点：**消息发送者通过指定不同的路由键将消息发送到交换机，交换机根据路由键将消息发送到对应的队列。</li><li>**应用场景：**适用于消息的有选择性地路由，例如根据消息内容进行过滤。</li></ul><p><strong>5. 主题模式（Topic Mode）</strong></p><ul><li>**特点：**消息发送者通过指定主题（可以使用通配符）将消息发送到交换机，交换机根据主题将消息发送到对应的队列。</li><li>**应用场景：**适用于消息的多样性路由，例如根据不同的主题进行过滤和选择。</li></ul><h3 id="_2-rabbitmq-消息可靠性" tabindex="-1"><a class="header-anchor" href="#_2-rabbitmq-消息可靠性"><span>2. RabbitMQ 消息可靠性</span></a></h3><p><strong>生产端（Producer）的可靠性保证措施：</strong></p><p>发布者确认（Publisher Confirms）：生产者可以通过启用发布者确认机制，在消息成功发送给 RabbitMQ后接收确认回执，确保消息已被正确接收。</p><p><strong>服务端（Broker）的可靠性保证措施：</strong></p><ul><li>持久化（Durability）：队列和交换机可设置为持久化，使其在 RabbitMQ 重新启动后不会丢失。</li><li>持久化消息：被标记为持久化的消息，会写入磁盘，确保消息在服务器故障时不会丢失。</li><li>事务机制（Transactions）：可通过启用事务机制将一组操作包装在事务中，要么全部成功执行，要么全部回滚，保证消息的原子性和一致性处理。</li></ul><p><strong>消费端（Consumer）的可靠性保证措施：</strong></p><p>手动消息确认（Manual Message Acknowledgement）：消费者在处理完消息后，发送确认回执给 RabbitMQ，告知消息已被成功处理，RabbitMQ 可以删除该消息。</p><h3 id="_3-rabbitmq-死信队列" tabindex="-1"><a class="header-anchor" href="#_3-rabbitmq-死信队列"><span>3. RabbitMQ 死信队列</span></a></h3><p>RabbitMQ 的死信队列（Dead Letter Queue）是用来处理无法被正常消费或处理的消息的特殊队列。</p><ol><li>**消息被拒绝（Rejected）：**当消费者拒绝消费消息或者消息超过消费者的最大重试次数时，消息会被发送到死信队列。</li><li>**消息过期（Expired）：**如果消息在一定时间内没有被消费者处理，即超过了消息的过期时间，该消息也会被发送到死信队列。</li><li><strong>队列达到最大长度（Queue Length Limit）</strong>：当队列达到了定义的最大长度限制，新的消息无法进入队列，会将旧的消息发送到死信队列。</li></ol><p>通过配置死信交换机（Dead Letter Exchange）和死信队列（Dead Letter Queue）的绑定关系，可以将满足上述条件的消息发送到指定的死信队列中，以便进行后续的处理或分析。</p><h3 id="_4-rabbitmq-消息重复消费" tabindex="-1"><a class="header-anchor" href="#_4-rabbitmq-消息重复消费"><span>4. RabbitMQ 消息重复消费</span></a></h3><ol><li>消费者应用程序在处理消息时发生了错误，导致消息确认（ack）没有发送给 RabbitMQ，从而导致 RabbitMQ 将消息重新分发给其他消费者进行消费。</li><li>网络问题或消费者应用程序重启时，RabbitMQ 无法收到消息确认，也会导致消息重新分发。</li></ol><p><strong>解决措施：</strong></p><ol><li>消费端幂等性：消费者应用程序在处理消息时需要保证幂等性，即无论接收到相同的消息多少次，处理结果都保持一致。这可以通过使用唯一标识符、幂等存储等方式实现。</li><li>消息去重：消费者应用程序在处理消息之前，可以在自己的系统中维护一个消息记录表，记录已经处理过的消息的唯一标识符。在接收到新消息时，先检查该消息是否已经处理过，如果已经处理过，则忽略重复消息。</li><li>消息确认机制：消费者应及时地发送消息确认（ack）给 RabbitMQ，表示已经成功处理了消息。这样 RabbitMQ 就不会将消息重新分发给其他消费者。</li></ol><p>保证消费端的幂等性是解决消息重复消费问题的关键。通过在消费者应用程序中实现幂等性逻辑和消息去重措施，可以保证即使同一条消息被重复消费，也不会对系统产生重复、不一致的影响。</p><p>最简回答：RabbitMQ 消息重复消费问题是由消费者应用程序错误或网络问题导致的，造成消息未得到确认，从而重新分发。为了解决问题，可以实现消费端的幂等性来保证消息处理结果一致，同时使用消息去重和及时发送消息确认，避免重复消费。确保消费幂等性是解决消息重复消费问题的重要措施之一。</p><h3 id="_5-rocketmq-特点" tabindex="-1"><a class="header-anchor" href="#_5-rocketmq-特点"><span>5. RocketMQ 特点</span></a></h3><p>RocketMQ作为一款纯java、分布式、队列模型的消息中间件，支持事务消息、顺序消息、批量消息、定时消息、消息回溯等。</p><p>特点：</p><p>• 支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型</p><p>• 在一个队列中可靠的先进先出（FIFO）和严格的顺序传递 （RocketMQ可以保证严格的消息顺序，而ActiveMQ无法保证）</p><p>• 支持拉（pull）和推（push）两种消息模式。pull其实就是消费者主动从MQ中去拉消息，而push则像rabbit MQ一样，是MQ给消费者推送消息</p><p>• 支持多种消息协议，如 JMS、MQTT 等</p><p>• 分布式高可用的部署架构,满足至少一次消息传递语义（RocketMQ原生就是支持分布式的，而ActiveMQ原生存在单点性）</p><p>• 提供 docker 镜像用于隔离测试和云集群部署</p><p>• 提供配置、指标和监控等功能丰富的 Dashboard</p><h3 id="_6-rocketmq-概念" tabindex="-1"><a class="header-anchor" href="#_6-rocketmq-概念"><span>6. RocketMQ 概念</span></a></h3><p><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324627.png" alt="img" loading="lazy"><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324628.png" alt="img" loading="lazy"></p><h3 id="_7-rocketmq-组件" tabindex="-1"><a class="header-anchor" href="#_7-rocketmq-组件"><span>7. RocketMQ 组件</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324629.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324630.png" alt="img" loading="lazy"><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324631.png" alt="img" loading="lazy"><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324632.png" alt="img" loading="lazy"></p><h3 id="_8-rocketmq-交互过程" tabindex="-1"><a class="header-anchor" href="#_8-rocketmq-交互过程"><span>8. RocketMQ 交互过程</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324633.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_9-常用中间件比较" tabindex="-1"><a class="header-anchor" href="#_9-常用中间件比较"><span>9. 常用中间件比较</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324634.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_10-xxl-job-概念" tabindex="-1"><a class="header-anchor" href="#_10-xxl-job-概念"><span>10. XXL-JOB 概念</span></a></h3><p>xxl-job 是一个分布式任务调度框架，主要用于解决大规模分布式系统中的定时调度和任务管理问题。它提供了可视化的任务管理界面和强大的调度功能，可以方便地实现定时任务的配置、监控和执行。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324635.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_11-xxl-job-使用" tabindex="-1"><a class="header-anchor" href="#_11-xxl-job-使用"><span>11. XXL-JOB 使用</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324636.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_12-seata-使用" tabindex="-1"><a class="header-anchor" href="#_12-seata-使用"><span>12. SEATA 使用</span></a></h3><ol><li>在服务中引入 <strong>Seata 依赖</strong>。</li><li>配置 Seata 的<strong>全局事务切面</strong>和<strong>数据源代理</strong>。</li><li>在需要进行分布式事务管理的方法上添加**@GlobalTransactional 注解**。</li><li>在代码中进行正常的业务操作，Seata 会自动进行事务管理和协调。</li></ol><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324637.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="九、部署" tabindex="-1"><a class="header-anchor" href="#九、部署"><span>九、部署</span></a></h2><h3 id="_1-linux" tabindex="-1"><a class="header-anchor" href="#_1-linux"><span>1. Linux</span></a></h3><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324638.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_2-docker" tabindex="-1"><a class="header-anchor" href="#_2-docker"><span>2. Docker</span></a></h3><p>Docker是基于Go语言实现的云开源项目。Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。</p><figure><img src="https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324639.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_3-nginx" tabindex="-1"><a class="header-anchor" href="#_3-nginx"><span>3. Nginx</span></a></h3><ul><li>**反向代理：**将多台服务器代理成一台服务器。</li><li><strong>负载均衡</strong>：将多个请求均匀的分配到多台服务器上，减轻每台服务器的压力，提高服务的吞吐量。</li><li><strong>动静分离</strong>：nginx 可以用作静态文件的缓存服务器，提高访问速度</li></ul>`,852))])}const g=s(l,[["render",h],["__file","八股文.html.vue"]]),k=JSON.parse('{"path":"/posts/Java/%E5%85%AB%E8%82%A1%E6%96%87.html","title":"八股文","lang":"zh-CN","frontmatter":{"title":"八股文","icon":"pen-to-square","order":1,"author":"Twritetime","date":"2024-10-27T00:00:00.000Z","category":["Java"],"tag":["红"],"sticky":true,"star":true,"copyright":"Copyright © 2024 Twritetime","head":[["meta",{"property":"og:url","content":"https://blog.writetime.top/posts/Java/%E5%85%AB%E8%82%A1%E6%96%87.html"}],["meta",{"property":"og:site_name","content":"Twritetime"}],["meta",{"property":"og:title","content":"八股文"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324526.jpeg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-21T14:07:24.000Z"}],["meta",{"property":"article:author","content":"Twritetime"}],["meta",{"property":"article:tag","content":"红"}],["meta",{"property":"article:published_time","content":"2024-10-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-21T14:07:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"八股文\\",\\"image\\":[\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324526.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324528.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324529.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324530.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324531.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324532.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324533.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324534.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324535.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324536.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324537.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324538.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324539.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324540.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324541.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324542.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324543.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324544.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324545.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324546.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324547.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324548.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324549.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324550.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324551.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324552.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324553.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324554.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324555.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324556.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324557.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324558.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324559.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324560.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324561.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324562.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324563.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324564.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324565.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324566.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324567.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324568.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324569.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324570.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324571.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324572.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324573.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324574.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324575.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324576.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324577.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324578.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324579.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324580.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324581.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324582.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324583.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324584.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324585.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324586.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324587.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324588.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324589.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324590.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324591.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324592.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324593.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324594.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324595.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324596.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324597.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324598.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324599.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324600.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324601.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324602.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324603.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324604.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324605.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324606.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324607.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324608.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324609.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324610.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324611.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324612.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324613.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324614.jpeg\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324615.webp\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324616.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324617.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324618.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324619.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324620.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324621.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324622.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324623.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324624.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324625.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324626.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324627.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324628.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324629.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324630.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324631.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324632.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324633.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324634.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324635.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324636.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324637.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324638.png\\",\\"https://gcore.jsdelivr.net/gh/Twritetime/Images-0@main/blog-writetime/20241217211324639.png\\"],\\"datePublished\\":\\"2024-10-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-21T14:07:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Twritetime\\"}]}"]]},"headers":[{"level":2,"title":"typora-root-url: ./..\\\\images","slug":"typora-root-url-images","link":"#typora-root-url-images","children":[]},{"level":2,"title":"一、基础","slug":"一、基础","link":"#一、基础","children":[{"level":3,"title":"1.  面向对象和面向过程的区别","slug":"_1-面向对象和面向过程的区别","link":"#_1-面向对象和面向过程的区别","children":[]},{"level":3,"title":"2. 面向对象三大特性","slug":"_2-面向对象三大特性","link":"#_2-面向对象三大特性","children":[]},{"level":3,"title":"3. String/StringBuffer/StringBuilder 区别","slug":"_3-string-stringbuffer-stringbuilder-区别","link":"#_3-string-stringbuffer-stringbuilder-区别","children":[]},{"level":3,"title":"4. == 和 equals 的区别","slug":"_4-和-equals-的区别","link":"#_4-和-equals-的区别","children":[]},{"level":3,"title":"5. 接口和抽象类的区别","slug":"_5-接口和抽象类的区别","link":"#_5-接口和抽象类的区别","children":[]},{"level":3,"title":"6. 重写和重载的区别","slug":"_6-重写和重载的区别","link":"#_6-重写和重载的区别","children":[]},{"level":3,"title":"7. 浅拷贝和深拷贝的区别","slug":"_7-浅拷贝和深拷贝的区别","link":"#_7-浅拷贝和深拷贝的区别","children":[]},{"level":3,"title":"8. 值传递和引用传递的区别","slug":"_8-值传递和引用传递的区别","link":"#_8-值传递和引用传递的区别","children":[]},{"level":3,"title":"9. IO 流","slug":"_9-io-流","link":"#_9-io-流","children":[]},{"level":3,"title":"10. 反射","slug":"_10-反射","link":"#_10-反射","children":[]},{"level":3,"title":"11. sleep 和 wait 的区别","slug":"_11-sleep-和-wait-的区别","link":"#_11-sleep-和-wait-的区别","children":[]},{"level":3,"title":"12. JVM 内存模型","slug":"_12-jvm-内存模型","link":"#_12-jvm-内存模型","children":[]},{"level":3,"title":"13. JVM 类加载器","slug":"_13-jvm-类加载器","link":"#_13-jvm-类加载器","children":[]},{"level":3,"title":"14. JVM 双亲委派机制","slug":"_14-jvm-双亲委派机制","link":"#_14-jvm-双亲委派机制","children":[]},{"level":3,"title":"15. JVM 垃圾回收算法","slug":"_15-jvm-垃圾回收算法","link":"#_15-jvm-垃圾回收算法","children":[]}]},{"level":2,"title":"二、集合","slug":"二、集合","link":"#二、集合","children":[{"level":3,"title":"1. Java 常用的集合、分类、接口","slug":"_1-java-常用的集合、分类、接口","link":"#_1-java-常用的集合、分类、接口","children":[]},{"level":3,"title":"2. ArrayList 和 Array（数组）的区别","slug":"_2-arraylist-和-array-数组-的区别","link":"#_2-arraylist-和-array-数组-的区别","children":[]},{"level":3,"title":"3. ArrayList 与 LinkedList 区别","slug":"_3-arraylist-与-linkedlist-区别","link":"#_3-arraylist-与-linkedlist-区别","children":[]},{"level":3,"title":"4. HashSet、LinkedHashSet 和 TreeSet 异同","slug":"_4-hashset、linkedhashset-和-treeset-异同","link":"#_4-hashset、linkedhashset-和-treeset-异同","children":[]},{"level":3,"title":"5. HashMap 底层原理","slug":"_5-hashmap-底层原理","link":"#_5-hashmap-底层原理","children":[]},{"level":3,"title":"6. ConcurrentHashMap 和 Hashtable 的区别","slug":"_6-concurrenthashmap-和-hashtable-的区别","link":"#_6-concurrenthashmap-和-hashtable-的区别","children":[]},{"level":3,"title":"7. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现","slug":"_7-concurrenthashmap-线程安全的具体实现方式-底层具体实现","link":"#_7-concurrenthashmap-线程安全的具体实现方式-底层具体实现","children":[]},{"level":3,"title":"8. JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？","slug":"_8-jdk-1-7-和-jdk-1-8-的-concurrenthashmap-实现有什么不同","link":"#_8-jdk-1-7-和-jdk-1-8-的-concurrenthashmap-实现有什么不同","children":[]}]},{"level":2,"title":"三、并发","slug":"三、并发","link":"#三、并发","children":[{"level":3,"title":"1.  线程和进程的区别","slug":"_1-线程和进程的区别","link":"#_1-线程和进程的区别","children":[]},{"level":3,"title":"2. 创建线程的方式","slug":"_2-创建线程的方式","link":"#_2-创建线程的方式","children":[]},{"level":3,"title":"3. 线程的生命周期和状态","slug":"_3-线程的生命周期和状态","link":"#_3-线程的生命周期和状态","children":[]},{"level":3,"title":"4. 线程上下文切换","slug":"_4-线程上下文切换","link":"#_4-线程上下文切换","children":[]},{"level":3,"title":"5. sleep() 和 wait() 方法对比","slug":"_5-sleep-和-wait-方法对比","link":"#_5-sleep-和-wait-方法对比","children":[]},{"level":3,"title":"6. 并发与并行的区别","slug":"_6-并发与并行的区别","link":"#_6-并发与并行的区别","children":[]},{"level":3,"title":"7. 同步和异步的区别","slug":"_7-同步和异步的区别","link":"#_7-同步和异步的区别","children":[]},{"level":3,"title":"8. 线程调度方式","slug":"_8-线程调度方式","link":"#_8-线程调度方式","children":[]},{"level":3,"title":"9. 死锁","slug":"_9-死锁","link":"#_9-死锁","children":[]},{"level":3,"title":"10. JMM","slug":"_10-jmm","link":"#_10-jmm","children":[]},{"level":3,"title":"11. 可见性","slug":"_11-可见性","link":"#_11-可见性","children":[]},{"level":3,"title":"12. 有序性","slug":"_12-有序性","link":"#_12-有序性","children":[]},{"level":3,"title":"13. 原子性","slug":"_13-原子性","link":"#_13-原子性","children":[]},{"level":3,"title":"14. CAS","slug":"_14-cas","link":"#_14-cas","children":[]},{"level":3,"title":"15. volatile 关键字","slug":"_15-volatile-关键字","link":"#_15-volatile-关键字","children":[]},{"level":3,"title":"16. synchronized 关键字","slug":"_16-synchronized-关键字","link":"#_16-synchronized-关键字","children":[]},{"level":3,"title":"17. synchronized 和 volatile 区别","slug":"_17-synchronized-和-volatile-区别","link":"#_17-synchronized-和-volatile-区别","children":[]},{"level":3,"title":"18. AQS","slug":"_18-aqs","link":"#_18-aqs","children":[]},{"level":3,"title":"19. ReentrantLock","slug":"_19-reentrantlock","link":"#_19-reentrantlock","children":[]},{"level":3,"title":"20. 公平锁和非公平锁的区别","slug":"_20-公平锁和非公平锁的区别","link":"#_20-公平锁和非公平锁的区别","children":[]},{"level":3,"title":"21. synchronized 和 lock 的区别","slug":"_21-synchronized-和-lock-的区别","link":"#_21-synchronized-和-lock-的区别","children":[]},{"level":3,"title":"22. synchronized 和 ReentrantLock 对比","slug":"_22-synchronized-和-reentrantlock-对比","link":"#_22-synchronized-和-reentrantlock-对比","children":[]},{"level":3,"title":"23. 可中断锁和不可中断锁的区别","slug":"_23-可中断锁和不可中断锁的区别","link":"#_23-可中断锁和不可中断锁的区别","children":[]},{"level":3,"title":"24. Atomic 原子类","slug":"_24-atomic-原子类","link":"#_24-atomic-原子类","children":[]},{"level":3,"title":"25. ThreadLocal 原理","slug":"_25-threadlocal-原理","link":"#_25-threadlocal-原理","children":[]},{"level":3,"title":"26. ThreadLocal 内存泄露","slug":"_26-threadlocal-内存泄露","link":"#_26-threadlocal-内存泄露","children":[]},{"level":3,"title":"27. 线程池的核心参数","slug":"_27-线程池的核心参数","link":"#_27-线程池的核心参数","children":[]},{"level":3,"title":"28. 线程池的创建","slug":"_28-线程池的创建","link":"#_28-线程池的创建","children":[]},{"level":3,"title":"29. 线程池工作原理","slug":"_29-线程池工作原理","link":"#_29-线程池工作原理","children":[]},{"level":3,"title":"30. 线程池的拒绝策略","slug":"_30-线程池的拒绝策略","link":"#_30-线程池的拒绝策略","children":[]},{"level":3,"title":"31. CountDownLatch","slug":"_31-countdownlatch","link":"#_31-countdownlatch","children":[]},{"level":3,"title":"32. CyclicBarrier","slug":"_32-cyclicbarrier","link":"#_32-cyclicbarrier","children":[]},{"level":3,"title":"33. CountDownLatch 和 CyclicBarrier 区别","slug":"_33-countdownlatch-和-cyclicbarrier-区别","link":"#_33-countdownlatch-和-cyclicbarrier-区别","children":[]},{"level":3,"title":"34. Semaphore","slug":"_34-semaphore","link":"#_34-semaphore","children":[]},{"level":3,"title":"35. ArrayBlockingQueue","slug":"_35-arrayblockingqueue","link":"#_35-arrayblockingqueue","children":[]},{"level":3,"title":"36. LinkedBloackingQueue","slug":"_36-linkedbloackingqueue","link":"#_36-linkedbloackingqueue","children":[]},{"level":3,"title":"37. 悲观锁和乐观锁的区别","slug":"_37-悲观锁和乐观锁的区别","link":"#_37-悲观锁和乐观锁的区别","children":[]}]},{"level":2,"title":"四、设计模式","slug":"四、设计模式","link":"#四、设计模式","children":[{"level":3,"title":"1. 分类","slug":"_1-分类","link":"#_1-分类","children":[]},{"level":3,"title":"2. 工厂模式","slug":"_2-工厂模式","link":"#_2-工厂模式","children":[]},{"level":3,"title":"3. 单例模式","slug":"_3-单例模式","link":"#_3-单例模式","children":[]},{"level":3,"title":"4. 代理模式","slug":"_4-代理模式","link":"#_4-代理模式","children":[]},{"level":3,"title":"5. 策略模式","slug":"_5-策略模式","link":"#_5-策略模式","children":[]},{"level":3,"title":"6. Spring 框架中用到了哪些设计模式？","slug":"_6-spring-框架中用到了哪些设计模式","link":"#_6-spring-框架中用到了哪些设计模式","children":[]},{"level":3,"title":"7. MyBatis 中有哪些设计模式","slug":"_7-mybatis-中有哪些设计模式","link":"#_7-mybatis-中有哪些设计模式","children":[]}]},{"level":2,"title":"五、MySQL","slug":"五、mysql","link":"#五、mysql","children":[{"level":3,"title":"1. 事务","slug":"_1-事务","link":"#_1-事务","children":[]},{"level":3,"title":"2. ACID 特性","slug":"_2-acid-特性","link":"#_2-acid-特性","children":[]},{"level":3,"title":"3. 隔离级别","slug":"_3-隔离级别","link":"#_3-隔离级别","children":[]},{"level":3,"title":"4. 锁","slug":"_4-锁","link":"#_4-锁","children":[]},{"level":3,"title":"5. MVCC","slug":"_5-mvcc","link":"#_5-mvcc","children":[]},{"level":3,"title":"6. 索引","slug":"_6-索引","link":"#_6-索引","children":[]},{"level":3,"title":"7. 三大日志","slug":"_7-三大日志","link":"#_7-三大日志","children":[]},{"level":3,"title":"8. 存储引擎","slug":"_8-存储引擎","link":"#_8-存储引擎","children":[]},{"level":3,"title":"9. 优化方案","slug":"_9-优化方案","link":"#_9-优化方案","children":[]}]},{"level":2,"title":"六、Redis","slug":"六、redis","link":"#六、redis","children":[{"level":3,"title":"1. 什么是 Redis","slug":"_1-什么是-redis","link":"#_1-什么是-redis","children":[]},{"level":3,"title":"2. Redis 优点","slug":"_2-redis-优点","link":"#_2-redis-优点","children":[]},{"level":3,"title":"3. Redis 应用场景","slug":"_3-redis-应用场景","link":"#_3-redis-应用场景","children":[]},{"level":3,"title":"4. Redis 数据类型","slug":"_4-redis-数据类型","link":"#_4-redis-数据类型","children":[]},{"level":3,"title":"5. Redis 持久化机制","slug":"_5-redis-持久化机制","link":"#_5-redis-持久化机制","children":[]},{"level":3,"title":"6. Redis 的缓存穿透、缓存击穿、缓存雪崩（缓存三兄弟）","slug":"_6-redis-的缓存穿透、缓存击穿、缓存雪崩-缓存三兄弟","link":"#_6-redis-的缓存穿透、缓存击穿、缓存雪崩-缓存三兄弟","children":[]},{"level":3,"title":"7. Redis 的哨兵集群（Redis Sentinel）","slug":"_7-redis-的哨兵集群-redis-sentinel","link":"#_7-redis-的哨兵集群-redis-sentinel","children":[]},{"level":3,"title":"8. Redis 的分片集群（Redis Cluster）","slug":"_8-redis-的分片集群-redis-cluster","link":"#_8-redis-的分片集群-redis-cluster","children":[]},{"level":3,"title":"9. Redis（或 ElasticSearch）和 MySQL 如何保持数据一致性","slug":"_9-redis-或-elasticsearch-和-mysql-如何保持数据一致性","link":"#_9-redis-或-elasticsearch-和-mysql-如何保持数据一致性","children":[]},{"level":3,"title":"10. Redis 分布式锁","slug":"_10-redis-分布式锁","link":"#_10-redis-分布式锁","children":[]},{"level":3,"title":"11. Redisson 是什么，怎么用","slug":"_11-redisson-是什么-怎么用","link":"#_11-redisson-是什么-怎么用","children":[]},{"level":3,"title":"12. Redisson 看门狗机制的原理","slug":"_12-redisson-看门狗机制的原理","link":"#_12-redisson-看门狗机制的原理","children":[]},{"level":3,"title":"13. Redis bigkey（大key）","slug":"_13-redis-bigkey-大key","link":"#_13-redis-bigkey-大key","children":[]},{"level":3,"title":"14. Redis hotkey（热Key）","slug":"_14-redis-hotkey-热key","link":"#_14-redis-hotkey-热key","children":[]}]},{"level":2,"title":"七、微服务","slug":"七、微服务","link":"#七、微服务","children":[{"level":3,"title":"1. Spring","slug":"_1-spring","link":"#_1-spring","children":[]},{"level":3,"title":"2. Spring IOC","slug":"_2-spring-ioc","link":"#_2-spring-ioc","children":[]},{"level":3,"title":"3. Spring AOP","slug":"_3-spring-aop","link":"#_3-spring-aop","children":[]},{"level":3,"title":"4. 声明成 Bean 注解的方式","slug":"_4-声明成-bean-注解的方式","link":"#_4-声明成-bean-注解的方式","children":[]},{"level":3,"title":"5. @Component 和 @Bean 区别","slug":"_5-component-和-bean-区别","link":"#_5-component-和-bean-区别","children":[]},{"level":3,"title":"6. @Autowired 和 @Resource 的区别","slug":"_6-autowired-和-resource-的区别","link":"#_6-autowired-和-resource-的区别","children":[]},{"level":3,"title":"7. 注入 Bean 的方式","slug":"_7-注入-bean-的方式","link":"#_7-注入-bean-的方式","children":[]},{"level":3,"title":"8. Spring MVC 原理","slug":"_8-spring-mvc-原理","link":"#_8-spring-mvc-原理","children":[]},{"level":3,"title":"9. SpringBoot 优点","slug":"_9-springboot-优点","link":"#_9-springboot-优点","children":[]},{"level":3,"title":"10. SpringBoot 自动配置原理","slug":"_10-springboot-自动配置原理","link":"#_10-springboot-自动配置原理","children":[]},{"level":3,"title":"11. SpringBoot 启动事项","slug":"_11-springboot-启动事项","link":"#_11-springboot-启动事项","children":[]},{"level":3,"title":"12. Spring Security","slug":"_12-spring-security","link":"#_12-spring-security","children":[]},{"level":3,"title":"13. MyBatis #{} 和 ${} 区别","slug":"_13-mybatis-和-区别","link":"#_13-mybatis-和-区别","children":[]},{"level":3,"title":"14. MyBatis 动态 SQL","slug":"_14-mybatis-动态-sql","link":"#_14-mybatis-动态-sql","children":[]},{"level":3,"title":"15. ResultType 和 ResultMap 的区别","slug":"_15-resulttype-和-resultmap-的区别","link":"#_15-resulttype-和-resultmap-的区别","children":[]},{"level":3,"title":"16. Mybatis 和 Hibernate 区别","slug":"_16-mybatis-和-hibernate-区别","link":"#_16-mybatis-和-hibernate-区别","children":[]},{"level":3,"title":"17. MyBatisPlus 常用注解","slug":"_17-mybatisplus-常用注解","link":"#_17-mybatisplus-常用注解","children":[]},{"level":3,"title":"18. SpringCloud 组件","slug":"_18-springcloud-组件","link":"#_18-springcloud-组件","children":[]},{"level":3,"title":"19. Eureka 工作原理","slug":"_19-eureka-工作原理","link":"#_19-eureka-工作原理","children":[]},{"level":3,"title":"20. Nacos 工作原理","slug":"_20-nacos-工作原理","link":"#_20-nacos-工作原理","children":[]},{"level":3,"title":"21. Nacos 和 Eureka 的区别","slug":"_21-nacos-和-eureka-的区别","link":"#_21-nacos-和-eureka-的区别","children":[]},{"level":3,"title":"22. Ribbon 工作原理","slug":"_22-ribbon-工作原理","link":"#_22-ribbon-工作原理","children":[]},{"level":3,"title":"23. Feign 工作原理","slug":"_23-feign-工作原理","link":"#_23-feign-工作原理","children":[]},{"level":3,"title":"24. Hystrix 工作原理","slug":"_24-hystrix-工作原理","link":"#_24-hystrix-工作原理","children":[]},{"level":3,"title":"25. Sentinel 工作原理","slug":"_25-sentinel-工作原理","link":"#_25-sentinel-工作原理","children":[]},{"level":3,"title":"26. Gateway 工作原理","slug":"_26-gateway-工作原理","link":"#_26-gateway-工作原理","children":[]},{"level":3,"title":"27. Skywalking 工作原理","slug":"_27-skywalking-工作原理","link":"#_27-skywalking-工作原理","children":[]}]},{"level":2,"title":"八、分布式","slug":"八、分布式","link":"#八、分布式","children":[{"level":3,"title":"1. RabbitMQ 工作模式","slug":"_1-rabbitmq-工作模式","link":"#_1-rabbitmq-工作模式","children":[]},{"level":3,"title":"2. RabbitMQ 消息可靠性","slug":"_2-rabbitmq-消息可靠性","link":"#_2-rabbitmq-消息可靠性","children":[]},{"level":3,"title":"3. RabbitMQ 死信队列","slug":"_3-rabbitmq-死信队列","link":"#_3-rabbitmq-死信队列","children":[]},{"level":3,"title":"4. RabbitMQ 消息重复消费","slug":"_4-rabbitmq-消息重复消费","link":"#_4-rabbitmq-消息重复消费","children":[]},{"level":3,"title":"5. RocketMQ 特点","slug":"_5-rocketmq-特点","link":"#_5-rocketmq-特点","children":[]},{"level":3,"title":"6. RocketMQ 概念","slug":"_6-rocketmq-概念","link":"#_6-rocketmq-概念","children":[]},{"level":3,"title":"7. RocketMQ 组件","slug":"_7-rocketmq-组件","link":"#_7-rocketmq-组件","children":[]},{"level":3,"title":"8. RocketMQ 交互过程","slug":"_8-rocketmq-交互过程","link":"#_8-rocketmq-交互过程","children":[]},{"level":3,"title":"9. 常用中间件比较","slug":"_9-常用中间件比较","link":"#_9-常用中间件比较","children":[]},{"level":3,"title":"10. XXL-JOB 概念","slug":"_10-xxl-job-概念","link":"#_10-xxl-job-概念","children":[]},{"level":3,"title":"11. XXL-JOB 使用","slug":"_11-xxl-job-使用","link":"#_11-xxl-job-使用","children":[]},{"level":3,"title":"12. SEATA 使用","slug":"_12-seata-使用","link":"#_12-seata-使用","children":[]}]},{"level":2,"title":"九、部署","slug":"九、部署","link":"#九、部署","children":[{"level":3,"title":"1. Linux","slug":"_1-linux","link":"#_1-linux","children":[]},{"level":3,"title":"2. Docker","slug":"_2-docker","link":"#_2-docker","children":[]},{"level":3,"title":"3. Nginx","slug":"_3-nginx","link":"#_3-nginx","children":[]}]}],"git":{"createdTime":1734790044000,"updatedTime":1734790044000,"contributors":[{"name":"Twritetime","email":"1124964426@qq.com","commits":1}]},"readingTime":{"minutes":104.66,"words":31397},"filePathRelative":"posts/Java/八股文.md","localizedDate":"2024年10月27日","excerpt":""}');export{g as comp,k as data};
